<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>食分速递项目</title>
      <link href="/2025/01/03/%E9%A3%9F%E5%88%86%E9%80%9F%E9%80%92%E9%A1%B9%E7%9B%AE/"/>
      <url>/2025/01/03/%E9%A3%9F%E5%88%86%E9%80%9F%E9%80%92%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="一-环境搭建"><a href="#一-环境搭建" class="headerlink" title="一 环境搭建"></a>一 环境搭建</h2><p><img src="4.png"></p><h3 id="1-前端环境搭建"><a href="#1-前端环境搭建" class="headerlink" title="1.前端环境搭建"></a>1.前端环境搭建</h3><p><strong>前端工程基于 nginx 运行</strong></p><h4 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h4><p>在nginx安装的文件夹内，双击 nginx.exe 即可启动 nginx 服务，访问端口号为 80</p><h4 id="什么是nginx？"><a href="#什么是nginx？" class="headerlink" title="什么是nginx？"></a>什么是nginx？</h4><p>nginx 反向代理，就是将前端发送的<strong>动态请求</strong>由 nginx 转发到<strong>后端服务器</strong></p><ul><li><strong>位置</strong>：运行在你的<strong>服务器</strong>上。</li><li><strong>职责</strong>：<strong>接收、调度、分发</strong>请求。它是请求到达服务器后遇到的第一个“门卫”和“调度员”。它不处理核心业务逻辑（比如计算订单金额），但它决定把这个请求交给谁去处理，或者直接自己处理（比如直接返回一个图片文件）。</li></ul><h4 id="nginx-反向代理的好处"><a href="#nginx-反向代理的好处" class="headerlink" title="nginx 反向代理的好处"></a>nginx 反向代理的好处</h4><p>•提高访问速度</p><p>•进行负载均衡</p><p>•保证后端服务安全</p><p>所谓<strong>负载均衡</strong>,就是把大量的请求按照我们指定的方式均衡的分配给集群中的每台服务器</p><img src="5.png" style="zoom: 50%;"><h4 id="nginx-反向代理的配置方式"><a href="#nginx-反向代理的配置方式" class="headerlink" title="nginx 反向代理的配置方式"></a>nginx 反向代理的配置方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen <span class="number">80</span>;</span><br><span class="line">server_name localhost;</span><br><span class="line"></span><br><span class="line">location /api/ &#123;</span><br><span class="line">            proxy_pass   http:<span class="comment">//localhost:8080/admin/;  #反向代理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**listen 80;**监听80端口</p><p><strong>逐行详解</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br></pre></td></tr></table></figure><ul><li><strong>定义一个虚拟服务器</strong>：Nginx 可以同时托管多个网站（虚拟主机），每个 <code>server {}</code> 块就是一个网站的配置。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen 80;</span><br></pre></td></tr></table></figure><ul><li><strong>监听端口</strong>：这个虚拟服务器会监听来自 <strong>80 端口</strong> 的 HTTP 请求（80 是 HTTP 协议的默认端口）。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_name localhost;</span><br></pre></td></tr></table></figure><ul><li><strong>服务器名称</strong>：这个虚拟服务器对应的域名是 <code>localhost</code>。当你在浏览器里访问 <code>http://localhost</code> 时，就会由这个 server 块来处理。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /api/ &#123;</span><br></pre></td></tr></table></figure><ul><li><strong>位置块</strong>：这是最核心的配置。它定义了一个 <strong>URL 路径匹配规则</strong>。所有以 <code>/api/</code> 开头的请求（例如 <code>http://localhost/api/employee/login</code>），都会进入这个 <code>location</code> 块内的逻辑。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_pass http://localhost:8080/admin/;</span><br></pre></td></tr></table></figure><ul><li><strong>反向代理指令</strong>：这是实现转发的关键命令。<ul><li>它告诉 Nginx，对于匹配到的请求，不要自己处理，而是将其 <strong>转发（代理）</strong> 到指定的地址。</li><li><code>http://localhost:8080/admin/</code> 是 <strong>目标地址</strong>。</li></ul></li></ul><img src="6.png" style="zoom:80%;"><h4 id="nginx-负载均衡的配置方式"><a href="#nginx-负载均衡的配置方式" class="headerlink" title="nginx 负载均衡的配置方式"></a>nginx 负载均衡的配置方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">upstream webservers&#123;</span><br><span class="line">server <span class="number">192.168</span><span class="number">.100</span><span class="number">.128</span>:<span class="number">8080</span>;</span><br><span class="line">server <span class="number">192.168</span><span class="number">.100</span><span class="number">.129</span>:<span class="number">8080</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">listen <span class="number">80</span>;</span><br><span class="line">server_name localhost;</span><br><span class="line"></span><br><span class="line">location /api/ &#123;</span><br><span class="line">            proxy_pass   http:<span class="comment">//webservers/admin/;  #负载均衡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. <code>upstream</code> 块 - 定义服务器池（后端集群）</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream webservers &#123;</span><br><span class="line">    server 192.168.100.128:8080;</span><br><span class="line">    server 192.168.100.129:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>upstream webservers {}</code></strong>：定义一个名为 <code>webservers</code> 的上游服务器组（也叫集群或服务器池）。</li><li><strong><code>server 192.168.100.128:8080;</code></strong>：在池中添加第一台后端服务器，IP 是 <code>192.168.100.128</code>，端口是 <code>8080</code>。</li><li><strong><code>server 192.168.100.129:8080;</code></strong>：在池中添加第二台后端服务器，IP 是 <code>192.168.100.129</code>，端口是 <code>8080</code>。</li></ul><p><strong>Nginx 默认的负载均衡策略是轮询</strong>，也就是说，第一个请求发给 128，第二个请求发给 129，第三个又发给 128，以此类推。</p><p><strong>2. <code>location</code> 块 - 流量分发</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /api/ &#123;</span><br><span class="line">    proxy_pass http://webservers/admin/;  #负载均衡</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关键变化在这里：<code>proxy_pass</code> 的目标不再是单一的服务器地址，而是指向了我们定义的 upstream 池 <code>http://webservers</code>。</li><li>这意味着，所有匹配到的请求都会被分发到 <code>webservers</code> 池中的服务器上。</li></ul><p><img src="7.png"></p><h3 id="2-后端环境搭建"><a href="#2-后端环境搭建" class="headerlink" title="2.后端环境搭建"></a>2.后端环境搭建</h3><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p>后端工程基于 maven 进行项目构建，并且进行分模块开发</p><p><img src="8.png"></p><p><img src="9.png"></p><p><strong>sky-common</strong> 子模块中存放的是一些公共类，可以供其他模块使用</p><p><strong>sky-pojo</strong> 子模块中存放的是一些 entity、DTO、VO</p><img src="10.png" style="zoom: 67%;"><p><strong>sky-server</strong> 子模块中存放的是 配置文件、配置类、拦截器、controller、service、mapper、启动类等</p><h4 id="使用Git进行版本控制"><a href="#使用Git进行版本控制" class="headerlink" title="使用Git进行版本控制"></a>使用Git进行版本控制</h4><p>.gitingore文件是git的相关文件，目的是忽略推送到服务器的文件或文件夹</p><p><img src="11.png"></p><p>还没有被git版本控制的项目可以在idea配置，具体操作是上方操作菜单点击VSC，点击创建git仓库，最后在弹出窗中选择项目</p><img src="12.png" style="zoom:50%;"><p>之后就可以测试提交，注意第一次提交会提交到本地仓库</p><p>推送就是要推送到远程仓库，第一次会提示你配置远程仓库信息</p><p><strong>核心概念总结</strong></p><table><thead><tr><th align="left">动作</th><th align="left">作用域</th><th align="left">描述</th><th align="left">影响</th><th align="left">类比</th></tr></thead><tbody><tr><td align="left"><strong><code>commit</code></strong></td><td align="left"><strong>本地</strong></td><td align="left">将<strong>暂存区</strong>的快照永久记录到<strong>本地仓库</strong>的历史中。</td><td align="left">只更新你自己电脑上的 Git 仓库。团队其他成员看不到你的这次提交。</td><td align="left"><strong>保存到本地硬盘</strong></td></tr><tr><td align="left"><strong><code>push</code></strong></td><td align="left"><strong>本地 → 远程</strong></td><td align="left">将<strong>本地仓库</strong>中的新提交记录上传到<strong>远程仓库</strong>（如 GitHub, Gitee）。</td><td align="left">更新共享的远程仓库，团队其他成员可以通过 <code>pull</code> 获取你的更新。</td><td align="left"><strong>上传到网盘&#x2F;服务器</strong></td></tr></tbody></table><p><strong>工作流程图示</strong></p><p>一个标准的 Git 协作流程如下：</p><p><strong>你的电脑</strong><br><code>工作区</code> –(<code>git add</code>)–&gt; <code>暂存区</code> –(<code>git commit</code>)–&gt; <code>本地仓库</code> –(<code>git push</code>)–&gt; <strong>远程仓库</strong></p><p><strong>同事的电脑拉远程仓库代码</strong><br><strong>远程仓库</strong> –(<code>git fetch</code>)–&gt; <strong>本地仓库</strong> –(<code>git checkout</code>)–&gt; <strong>工作区</strong></p><ul><li><strong>合并（Merge）</strong>：<strong>“邀请别人的成果加入我的版本”</strong><ul><li>操作：我站在原地不动，把别人完成的新内容<strong>拉过来</strong>，和我当前的内容<strong>融合</strong>在一起。如果内容有重叠（冲突），我需要手动调解。</li><li>结果：历史记录会留下一次“合并”的痕迹，标明两条线在这里汇合了。</li></ul></li><li><strong>变基（Rebase）</strong>：<strong>“把我的工作挪到最新的成果之上”</strong><ul><li>操作：我先把我的工作暂时<strong>放到一边</strong>，然后<strong>把别人的新成果作为新的基础</strong>，最后我再把我的工作<strong>重新实施</strong>在这个崭新的、最新的基础之上。</li><li>结果：历史记录看起来就像是我从一开始就是在最新的代码基础上进行工作的，一条直线，非常整洁。</li></ul></li></ul><p><strong>比喻</strong></p><p><strong>合并</strong>：你正在拼A部分，同事拼好了B部分。你直接把同事拼好的B部分拿过来，和你的A部分对接在一起。如果对接不上（冲突），你就需要调整一下接口。</p><p><strong>变基</strong>：你发现同事不仅拼好了B部分，还把你们共同的底座C也升级了。于是，你先把你的A部分拆下来，把升级后的新底座C换上去，然后再把你的A部分重新拼到新底座C上。</p><h3 id="3-swagger接口文档"><a href="#3-swagger接口文档" class="headerlink" title="3.swagger接口文档"></a>3.swagger接口文档</h3><h4 id="Knife4j使用方式"><a href="#Knife4j使用方式" class="headerlink" title="Knife4j使用方式"></a>Knife4j使用方式</h4><p><a href="https://doc.xiaominfo.com/">K</a><a href="https://doc.xiaominfo.com/">nife4j</a><a href="https://doc.xiaominfo.com/"> </a>是为Java MVC框架集成Swagger生成Api文档的增强解决方案</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>WebMvcConfiguration</strong>文件配置</p><p>1.在配置类中加入 knife4j 相关配置</p><p>2.设置静态资源映射，否则接口文档页面无法访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置类，注册web层相关组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenAdminInterceptor jwtTokenAdminInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册自定义拦截器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始注册自定义拦截器...&quot;</span>);</span><br><span class="line">        registry.addInterceptor(jwtTokenAdminInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/admin/**&quot;</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/admin/employee/login&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过knife4j生成接口文档</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApiInfo</span> <span class="variable">apiInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;苍穹外卖项目接口文档&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;2.0&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;苍穹外卖项目接口文档&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">Docket</span> <span class="variable">docket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.sky.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> docket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置静态资源映射</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/doc.html&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@Api</td><td>用在类上，例如Controller，表示对类的说明</td></tr><tr><td>@ApiModel</td><td>用在类上，例如entity、DTO、VO</td></tr><tr><td>@ApiModelProperty</td><td>用在属性上，描述属性信息</td></tr><tr><td>@ApiOperation</td><td>用在方法上，例如Controller的方法，说明方法的用途、作用</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件开发整体介绍</title>
      <link href="/2024/10/03/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/10/03/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="1-软件开发流程"><a href="#1-软件开发流程" class="headerlink" title="1.软件开发流程"></a>1.软件开发流程</h2><img src="1.png" style="zoom: 33%;"><h2 id="2-角色分工"><a href="#2-角色分工" class="headerlink" title="2.角色分工"></a>2.角色分工</h2><img src="2.png" style="zoom:50%;"><h2 id="3-软件环境"><a href="#3-软件环境" class="headerlink" title="3.软件环境"></a>3.软件环境</h2><p><img src="3.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用Hexo搭建个人博客</title>
      <link href="/2024/09/30/%E5%88%A9%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/09/30/%E5%88%A9%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-环境及工具准备"><a href="#1-环境及工具准备" class="headerlink" title="1.环境及工具准备"></a>1.环境及工具准备</h2><p>需要安装git和nodejs</p><p>安装完成后打开cmd控制台，输入命令<code>npm install hexo-cli -g</code>，安装Hexo</p><h2 id="2-仓库搭建"><a href="#2-仓库搭建" class="headerlink" title="2.仓库搭建"></a>2.仓库搭建</h2><p>进入github网站后，点击创建仓库<code>create repository</code></p><p><img src="1.png"></p><p>仓库名字最好是用户名+.github.io,设置为公开仓库，公选设置生成readme文件</p><p><img src="2.png"></p><h2 id="3-配置ssh-key"><a href="#3-配置ssh-key" class="headerlink" title="3.配置ssh key"></a>3.配置ssh key</h2><p>回到桌面右击鼠标选择G0it Bash Here</p><p>在命令行中输入：<code>ssh-keygen -t rsa -C &quot;邮箱地址&quot;</code></p><p>后面提示一直按enter回车键就行</p><p>之后进入本地磁盘C:\Users\用户名字\ .ssh</p><p>打开.pub文件，将里面的内容复制</p><p>之后回到github网站页面，点击右上角头像，选择setting，之后再点击ssh and gpg keys,然后再new ssh key</p><p><img src="3.png"></p><p>之后标题任意，把复制的ssh key粘贴在key填写框中</p><p><img src="5.png"></p><p>然后点击创建add ssh key</p><p>回到git命令窗口，输入<code>ssh -T git@github.com</code>，出现下方提示就成功了</p><p><img src="6.png"></p><h2 id="4-本地部署"><a href="#4-本地部署" class="headerlink" title="4.本地部署"></a>4.本地部署</h2><p>先在本地磁盘上创建一个文件夹，用于存放博客数据，这里我选择创建的是D:\BlogkFile目录</p><p>然后在此目录下右击鼠标选择git bash here</p><p>在命令窗口输入：<code>hexo init</code> 进行初始化</p><p>​   <code>npx hexo instal</code>l 安装</p><p>​   <code>npx hexo g </code>生成</p><p>​                               <code>npx hexo s</code> 本地部署</p><p>最后命令窗口会有一个链接，打开就可以进入本地部署的hexo了</p><p><img src="7.png"></p><p><img src="8.png"></p><p><strong>ctrl+c 停止本地服务器</strong></p><h2 id="5-上线博客"><a href="#5-上线博客" class="headerlink" title="5.上线博客"></a>5.上线博客</h2><p>打开文件夹中的config文件</p><p><img src="9.png"></p><p>复制这段文字：</p><p>type: git<br>repository:<br>branch: main</p><p>将它粘贴在config文件下面，将原来底部的type：‘ ’替换掉</p><p><img src="10.png"></p><p>之后回到github网站，回到自己的仓库，点击code复制git链接</p><p><img src="11.png"></p><p>将链接粘贴到config文件中的repository：旁边</p><p><img src="12.png"></p><p>保存退出，然后在本地博客文件夹中git bash here，输入命令<code>npx hexo g</code>，<code>npx hexo g</code>上传</p><p><strong>$ npx hexo d</strong><br><strong>INFO Validating config</strong><br><strong>ERROR Deployer not found: git</strong><br><strong>如果出现这个问题，在bash界面输入npm install hexo-deployer-git –save后再输入npx hexo d即可解决</strong></p><p>注意第一次使用要填写git邮箱与用户名字</p><p>然后结束后会弹窗，登入即可</p><h2 id="网站资料"><a href="#网站资料" class="headerlink" title="网站资料"></a>网站资料</h2><p>我们的博客标题还是默认的hexo，整个页面是初始默认的，接下来我们对其进行修改</p><p>用记事本打开我们blog文件夹中的_config.yml文件</p><p>将#Site下面按自己的需求填上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## Site</span><br><span class="line">title: 标题</span><br><span class="line">subtitle: 副标题</span><br><span class="line">description: 描述</span><br><span class="line">keywords: 关键词</span><br><span class="line">author: 站主</span><br><span class="line">language: 语言（可以填写zh-CN）</span><br><span class="line">timezone: 时区（可以填写Asia/Shanghai）</span><br></pre></td></tr></table></figure><p>然后保存</p><h2 id="如何上传文章"><a href="#如何上传文章" class="headerlink" title="如何上传文章"></a>如何上传文章</h2><p>我们在Blog文件夹中打开git bash,输入下方代码就可以生成新的文章md文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new 文章标题</span><br></pre></td></tr></table></figure><p>文章是.md格式，在我们的Blog文件夹中的source&#x2F;_posts中</p><p>推荐用Typora软件来编辑.md格式的文件</p><p>然后我们用Typora软件打开该.md文件就可以开始写文章了</p><p>写好以后，我们还是一样打开git bash生成、上传</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><hr><p>至此，我们就成功搭建好基本的博客了，剩下的就是对博客的一些优化和美化了。</p><p>推荐主题：<a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly</a>，<a href="http://docs.anheyu.com/">anzhiyu</a></p><h2 id="相关问题解决"><a href="#相关问题解决" class="headerlink" title="相关问题解决"></a>相关问题解决</h2><h3 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h3><p>这个错误 <code>fatal: unable to access &#39;https://github.com/mingea/mingea.github.io.git/&#39;: OpenSSL SSL_read: Connection was reset, errno 10054</code> 是一个典型的 <strong>网络连接问题</strong>，通常是 GitHub 连接被重置导致的。</p><p><strong>步骤：</strong></p><ol><li><p><strong>生成 SSH 密钥</strong>（如果你还没有）：</p><p>bash</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>直接按回车使用默认路径和空密码。</p></li><li><p><strong>将公钥添加到 GitHub</strong>：</p><ul><li>复制公钥内容：<code>cat ~/.ssh/id_rsa.pub</code></li><li>登录 GitHub → Settings → SSH and GPG keys → New SSH key</li><li>粘贴公钥内容</li></ul></li><li><p><strong>修改部署配置</strong>：<br>将 <code>_config.yml</code> 中的 repository地址改为 SSH 格式：</p><p>yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:mingea/mingea.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure></li><li><p><strong>测试 SSH 连接</strong>：</p><p>bash</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果显示 “You’ve successfully authenticated”，说明配置成功。</p></li><li><p><strong>重新部署</strong>：</p><p>bash</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx hexo clean &amp;&amp; npx hexo g &amp;&amp; npx hexo d</span><br></pre></td></tr></table></figure></li></ol><h3 id="图片加载问题"><a href="#图片加载问题" class="headerlink" title="图片加载问题"></a>图片加载问题</h3><ul><li>进入你博客的根目录，然后下面顺序找到<code>index.js</code>:<br><code>node_modules</code> –&gt; <code>hexo-asset-image</code> –&gt; <code>index.js</code></li><li>用<a href="https://zhida.zhihu.com/search?content_id=208599834&content_type=Article&match_order=1&q=VS+Code&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTk2MzAxMDIsInEiOiJWUyBDb2RlIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MjA4NTk5ODM0LCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.qFI2a32pQBViRBwWoK2sPR_ButdW9O7vrFdS459m-GM&zhida_source=entity">VS Code</a> 或者 记事本打开 <code>index.js</code></li><li>在第 58 行，可以找到这么一行代码：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, config.<span class="property">root</span> + link + src);</span><br></pre></td></tr></table></figure><ul><li>把这一行代码改成下面这样</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, src);</span><br></pre></td></tr></table></figure><ul><li>保存文件</li></ul><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ul><li>进入博客的根目录</li><li><code>node_modules</code> –&gt; <code>hexo-asset-image</code> –&gt; 打开 <code>README.md</code>, 里面写了用法。我截了个图：</li></ul><p><img src="https://pic3.zhimg.com/v2-743a77f20e7c4ed5e7dcf3aec2383672_1440w.png" alt="img"></p><p>Usage of hexo-asset-image</p><p><strong>注意</strong></p><ul><li>要先把 <code>_config.yml</code>中的 <code>post_asset_folder: false</code> 改成 <code>post_asset_folder: true</code> (默认是false，如果你没有修改过，那请去修改)</li><li>圆括号里面只要写 图片名.后缀 就可以了，不要多加任何的东西。</li></ul><p>最后，<code>hexo clean</code> <code>hexo g</code> <code>hexo s</code> 三部曲，然后进入浏览器打开<code>localhost:4000</code> 就可以看到你想要的图片.</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
            <tag> 标签2 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
