<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring MVC控制层框架 | 学习笔记</title><meta name="author" content="明"><meta name="copyright" content="明"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring MVC控制层框架目录 一、SpringMVC简介和体验 1. 介绍 2. 主要作用 3. 核心组件和调用流程理解 4. 快速体验   二、SpringMVC接收数据 1. 访问路径设置 2. 接收参数（重点） 2.1 param 和 json参数比较 2.2 param参数接收 2.3 路径 参数接收 2.4 json参数接收   3. 接收Cookie数据 4. 接收请求头数据 5">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring MVC控制层框架">
<meta property="og:url" content="http://example.com/2024/05/01/Spring%20MVC%E6%8E%A7%E5%88%B6%E5%B1%82%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="学习笔记">
<meta property="og:description" content="Spring MVC控制层框架目录 一、SpringMVC简介和体验 1. 介绍 2. 主要作用 3. 核心组件和调用流程理解 4. 快速体验   二、SpringMVC接收数据 1. 访问路径设置 2. 接收参数（重点） 2.1 param 和 json参数比较 2.2 param参数接收 2.3 路径 参数接收 2.4 json参数接收   3. 接收Cookie数据 4. 接收请求头数据 5">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-05-01T00:02:21.000Z">
<meta property="article:modified_time" content="2025-10-21T10:54:40.983Z">
<meta property="article:author" content="明">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Spring MVC控制层框架",
  "url": "http://example.com/2024/05/01/Spring%20MVC%E6%8E%A7%E5%88%B6%E5%B1%82%E6%A1%86%E6%9E%B6/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2024-05-01T00:02:21.000Z",
  "dateModified": "2025-10-21T10:54:40.983Z",
  "author": [
    {
      "@type": "Person",
      "name": "明",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/05/01/Spring%20MVC%E6%8E%A7%E5%88%B6%E5%B1%82%E6%A1%86%E6%9E%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring MVC控制层框架',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">学习笔记</span></a><a class="nav-page-title" href="/"><span class="site-name">Spring MVC控制层框架</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Spring MVC控制层框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-01T00:02:21.000Z" title="发表于 2024-05-01 08:02:21">2024-05-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-21T10:54:40.983Z" title="更新于 2025-10-21 18:54:40">2025-10-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E5%BC%80%E5%8F%91/">java开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Spring-MVC控制层框架"><a href="#Spring-MVC控制层框架" class="headerlink" title="Spring MVC控制层框架"></a>Spring MVC控制层框架</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E4%B8%80SpringMVC%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%93%E9%AA%8C">一、SpringMVC简介和体验</a><ul>
<li><a href="#1-%E4%BB%8B%E7%BB%8D">1. 介绍</a></li>
<li><a href="#2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8">2. 主要作用</a></li>
<li><a href="#3-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%92%8C%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E7%90%86%E8%A7%A3">3. 核心组件和调用流程理解</a></li>
<li><a href="#4-%E5%BF%AB%E9%80%9F%E4%BD%93%E9%AA%8C">4. 快速体验</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8CSpringMVC%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE">二、SpringMVC接收数据</a><ul>
<li><a href="#1-%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE">1. 访问路径设置</a></li>
<li><a href="#2-%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E9%87%8D%E7%82%B9">2. 接收参数（重点）</a><ul>
<li><a href="#21-param-%E5%92%8C-json%E5%8F%82%E6%95%B0%E6%AF%94%E8%BE%83">2.1 param 和 json参数比较</a></li>
<li><a href="#22-param%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6">2.2 param参数接收</a></li>
<li><a href="#23-%E8%B7%AF%E5%BE%84-%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6">2.3 路径 参数接收</a></li>
<li><a href="#24-json%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6">2.4 json参数接收</a></li>
</ul>
</li>
<li><a href="#3-%E6%8E%A5%E6%94%B6Cookie%E6%95%B0%E6%8D%AE">3. 接收Cookie数据</a></li>
<li><a href="#4-%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%95%B0%E6%8D%AE">4. 接收请求头数据</a></li>
<li><a href="#5-%E5%8E%9F%E7%94%9FApi%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C">5. 原生Api对象操作</a></li>
<li><a href="#6-%E5%85%B1%E4%BA%AB%E5%9F%9F%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C">6. 共享域对象操作</a><ul>
<li><a href="#61-%E5%B1%9E%E6%80%A7%E5%85%B1%E4%BA%AB%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9B%9E%E9%A1%BE">6.1 属性（共享）域作用回顾</a></li>
<li><a href="#62-Request%E7%BA%A7%E5%88%AB%E5%B1%9E%E6%80%A7%E5%85%B1%E4%BA%AB%E5%9F%9F">6.2 Request级别属性（共享）域</a></li>
<li><a href="#63-Session%E7%BA%A7%E5%88%AB%E5%B1%9E%E6%80%A7%E5%85%B1%E4%BA%AB%E5%9F%9F">6.3 Session级别属性（共享）域</a></li>
<li><a href="#64-Application%E7%BA%A7%E5%88%AB%E5%B1%9E%E6%80%A7%E5%85%B1%E4%BA%AB%E5%9F%9F">6.4 Application级别属性（共享）域</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89SpringMVC%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE">三、SpringMVC响应数据</a><ul>
<li><a href="#1-handler%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90">1. handler方法分析</a></li>
<li><a href="#2-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6">2. 页面跳转控制</a><ul>
<li><a href="#21-%E5%BF%AB%E9%80%9F%E8%BF%94%E5%9B%9Ejsp%E8%A7%86%E5%9B%BE">2.1 快速返回jsp视图</a></li>
<li><a href="#22-%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91">2.2 转发和重定向</a></li>
</ul>
</li>
<li><a href="#3-%E8%BF%94%E5%9B%9EJSON%E6%95%B0%E6%8D%AE%E9%87%8D%E7%82%B9">3. 返回JSON数据（重点）</a><ul>
<li><a href="#31-%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87">3.1 前置准备</a></li>
<li><a href="#32-ResponseBody">3.2 @ResponseBody</a></li>
<li><a href="#33-RestController">3.3 @RestController</a></li>
</ul>
</li>
<li><a href="#4-%E8%BF%94%E5%9B%9E%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86">4. 返回静态资源处理</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9BRESTFul%E9%A3%8E%E6%A0%BC%E8%AE%BE%E8%AE%A1">四、RESTFul风格设计</a><ul>
<li><a href="#1-RESTFul%E9%A3%8E%E6%A0%BC%E6%A6%82%E8%BF%B0">1. RESTFul风格概述</a><ul>
<li><a href="#11-RESTFul%E9%A3%8E%E6%A0%BC%E7%AE%80%E4%BB%8B">1.1 RESTFul风格简介</a></li>
<li><a href="#12-RESTFul%E9%A3%8E%E6%A0%BC%E7%89%B9%E7%82%B9">1.2 RESTFul风格特点</a></li>
<li><a href="#13-RESTFul%E9%A3%8E%E6%A0%BC%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83">1.3 RESTFul风格设计规范</a></li>
<li><a href="#14-RESTFul%E9%A3%8E%E6%A0%BC%E5%A5%BD%E5%A4%84">1.4 RESTFul风格好处</a></li>
</ul>
</li>
<li><a href="#2-RESTFul%E9%A3%8E%E6%A0%BC%E5%AE%9E%E6%88%98">2. RESTFul风格实战</a><ul>
<li><a href="#21-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">2.1 需求分析</a></li>
<li><a href="#22-RESTFul%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1">2.2 RESTFul风格接口设计</a></li>
<li><a href="#23-%E5%90%8E%E5%8F%B0%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0">2.3 后台接口实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%94%E5%9F%BA%E4%BA%8ERESTFul%E9%A3%8E%E6%A0%BC%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%BB%83%E4%B9%A0">五、基于RESTFul风格增删改查练习</a><ul>
<li><a href="#1-%E6%A1%88%E4%BE%8B%E5%8A%9F%E8%83%BD%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90">1. 案例功能和接口分析</a><ul>
<li><a href="#11-%E5%8A%9F%E8%83%BD%E9%A2%84%E8%A7%88">1.1 功能预览</a></li>
<li><a href="#12-%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90">1.2 接口分析</a></li>
</ul>
</li>
<li><a href="#2-%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87">2. 工程项目准备</a><ul>
<li><a href="#21-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA">2.1 前端项目搭建</a></li>
<li><a href="#22-%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA">2.2 后端项目搭建</a></li>
</ul>
</li>
<li><a href="#3-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E7%8E%B0">3. 增删改查实现</a><ul>
<li><a href="#41-%E9%A1%B9%E7%9B%AE%E6%A0%B9%E8%B7%AF%E5%BE%84%E8%AE%BE%E8%AE%A1">4.1 项目根路径设计</a></li>
<li><a href="#42-SpringMVC%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">4.2 SpringMVC解决跨域问题</a></li>
<li><a href="#43-%E4%B8%9A%E5%8A%A1%E5%AE%9E%E7%8E%B0">4.3 业务实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%ADSpringMVC%E5%85%B6%E4%BB%96%E6%89%A9%E5%B1%95">六、SpringMVC其他扩展</a><ul>
<li><a href="#1-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6">1. 异常处理机制</a><ul>
<li><a href="#11-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%A6%82%E5%BF%B5">1.1 异常处理概念</a></li>
<li><a href="#12-%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%82%E5%B8%B8%E5%A5%BD%E5%A4%84">1.2 声明式异常好处</a></li>
<li><a href="#13-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%BC%82%E5%B8%B8%E5%A3%B0%E6%98%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">1.3 基于注解异常声明异常处理</a></li>
</ul>
</li>
<li><a href="#2-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8">2. 拦截器使用</a><ul>
<li><a href="#21-%E6%8B%A6%E6%88%AA%E5%99%A8%E6%A6%82%E5%BF%B5">2.1 拦截器概念</a></li>
<li><a href="#22-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8">2.2 拦截器使用</a></li>
<li><a href="#23-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%9C%E7%94%A8%E4%BD%8D%E7%BD%AE%E5%9B%BE%E8%A7%A3">2.3 拦截器作用位置图解</a></li>
<li><a href="#24-%E6%8B%A6%E6%88%AA%E5%99%A8%E6%A1%88%E4%BE%8B">2.4 拦截器案例</a></li>
</ul>
</li>
<li><a href="#3-%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C">3. 参数校验</a></li>
<li><a href="#4%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD-">4.文件上传和下载 </a><ul>
<li><a href="#41-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">4.1 文件上传</a></li>
<li><a href="#42-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD">4.2 文件下载</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%83SpringMVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">七、SpringMVC底层原理</a><ul>
<li><a href="#1-%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B">1. 启动配置流程</a><ul>
<li><a href="#11-Servlet-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E9%A1%BE">1.1 Servlet 生命周期回顾</a></li>
<li><a href="#12-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C%E8%B0%83%E7%94%A8%E8%B7%AF%E7%BA%BF%E5%9B%BE">1.2 初始化操作调用路线图</a></li>
<li><a href="#13-SpringMVC-IoC-%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA">1.3 SpringMVC IoC 容器创建</a></li>
<li><a href="#14-%E5%B0%86-SpringMVC-IoC%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%85%A5%E5%BA%94%E7%94%A8%E5%9F%9F">1.4 将 SpringMVC IoC容器对象存入应用域</a></li>
<li><a href="#15-%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%88%9D%E5%A7%8B%E5%8C%96">1.5 请求映射初始化</a></li>
<li><a href="#16-%E5%B0%8F%E7%BB%93">1.6 小结</a></li>
</ul>
</li>
<li><a href="#2-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%8E%9F%E7%90%86">2. 请求处理流程原理</a><ul>
<li><a href="#21-%E6%80%BB%E4%BD%93%E9%98%B6%E6%AE%B5">2.1 总体阶段</a></li>
<li><a href="#22-%E8%B0%83%E7%94%A8%E5%89%8D%E9%98%B6%E6%AE%B5">2.2 调用前阶段</a></li>
<li><a href="#23%E8%B0%83%E7%94%A8%E5%90%8E%E9%98%B6%E6%AE%B5">2.3调用后阶段</a></li>
<li><a href="#24-%E6%89%80%E6%9C%89%E6%96%AD%E7%82%B9%E6%80%BB%E7%BB%93">2.4 所有断点总结</a></li>
</ul>
</li>
<li><a href="#3-ContextLoaderListener">3. ContextLoaderListener</a><ul>
<li><a href="#31-%E9%85%8D%E7%BD%AE%E5%88%86%E7%A6%BB%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98">3.1 配置分离相关问题</a></li>
<li><a href="#32-%E9%85%8D%E7%BD%AEContextLoaderListener">3.2 配置ContextLoaderListener</a></li>
<li><a href="#33-%E6%8E%A2%E8%AE%A8%E4%B8%A4%E4%B8%AAIoC%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB">3.3 探讨两个IoC容器之间关系</a></li>
<li><a href="#34-%E4%B8%A4%E4%B8%AAIoC%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4Bean%E8%AE%BF%E9%97%AE">3.4 两个IoC容器之间Bean访问</a></li>
<li><a href="#35-%E6%9C%89%E5%8F%AF%E8%83%BD%E9%87%8D%E5%A4%8D%E5%AF%B9%E8%B1%A1">3.5 有可能重复对象</a></li>
<li><a href="#35-%E5%B0%8F%E7%BB%93">3.5 小结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="一、SpringMVC简介和体验"><a href="#一、SpringMVC简介和体验" class="headerlink" title="一、SpringMVC简介和体验"></a>一、SpringMVC简介和体验</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/web/webmvc.html">https://docs.spring.io/spring-framework/reference/web/webmvc.html</a></p>
<p>Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。正式名称“Spring Web MVC”来自其源模块的名称（ <code>spring-webmvc</code> ），但它通常被称为“Spring MVC”。</p>
<p>在控制层框架历经Strust、WebWork、Strust2等诸多产品的历代更迭之后，目前业界普遍选择了SpringMVC作为Java EE项目表述层开发的<strong>首选方案</strong>。之所以能做到这一点，是因为SpringMVC具备如下显著优势：</p>
<ul>
<li><strong>Spring 家族原生产品</strong>，与IOC容器等基础设施无缝对接</li>
<li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></li>
<li><strong>代码清新简洁</strong>，大幅度提升开发效率</li>
<li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</li>
<li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</li>
</ul>
<p>原生Servlet API开发代码片段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span><br><span class="line">                                                        <span class="keyword">throws</span> ServletException, IOException &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;userName=&quot;</span>+userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于SpringMVC开发代码片段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(<span class="meta">@RequestParam(&quot;userName&quot;)</span> String userName,Sting password)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    log.debug(<span class="string">&quot;userName=&quot;</span>+userName);</span><br><span class="line">    <span class="comment">//调用业务即可</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-主要作用"><a href="#2-主要作用" class="headerlink" title="2. 主要作用"></a>2. 主要作用</h3><p>![](Spring MVC控制层框架&#x2F;image_s06VlXFk72.png)</p>
<p>SSM框架构建起单体项目的技术栈需求！其中的SpringMVC负责表述层（控制层）实现简化！</p>
<p>SpringMVC的作用主要覆盖的是表述层，例如：</p>
<ul>
<li>请求映射</li>
<li>数据输入</li>
<li>视图界面</li>
<li>请求分发</li>
<li>表单回显</li>
<li>会话控制</li>
<li>过滤拦截</li>
<li>异步交互</li>
<li>文件上传</li>
<li>文件下载</li>
<li>数据校验</li>
<li>类型转换</li>
<li>等等等</li>
</ul>
<p><strong>最终总结：</strong></p>
<ol>
<li>简化前端参数接收( 形参列表 )</li>
<li>简化后端数据响应( 返回值 )</li>
<li>以及其他……</li>
</ol>
<h3 id="3-核心组件和调用流程理解"><a href="#3-核心组件和调用流程理解" class="headerlink" title="3. 核心组件和调用流程理解"></a>3. 核心组件和调用流程理解</h3><p>Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 <code>Servlet</code>  <code>DispatcherServlet</code> 做整体请求处理调度！</p>
<p>除了<code>DispatcherServlet</code>SpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。</p>
<p><strong>SpringMVC处理请求流程：</strong></p>
<p>![](Spring MVC控制层框架&#x2F;image_IOG0UTDH–.png)</p>
<p><strong>SpringMVC涉及组件理解：</strong></p>
<ol>
<li>DispatcherServlet :  SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发！</li>
<li>HandlerMapping :  SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！</li>
<li>HandlerAdapter : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器！</li>
<li>Handler : handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果！</li>
<li>ViewResovler : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的！</li>
</ol>
<h3 id="4-快速体验"><a href="#4-快速体验" class="headerlink" title="4. 快速体验"></a>4. 快速体验</h3><ol>
<li><p>体验场景需求</p>
<p>![](Spring MVC控制层框架&#x2F;image_r6DxapBw-8.png)</p>
</li>
<li><p>配置分析</p>
<ol>
<li>DispatcherServlet，在web.xml配置！设置处理所有请求！</li>
<li>HandlerMapping,HandlerAdapter,Handler需要加入到IoC容器，供DS调用！</li>
<li>Handler自己声明（Controller）需要配置到HandlerMapping中供DS查找！</li>
</ol>
</li>
<li><p>准备项目</p>
<ol>
<li><p>创建项目</p>
<p>springmvc-base-quick</p>
<p>注意：需要转成maven&#x2F;web程序！！</p>
</li>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- springioc相关依赖  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- web相关依赖  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在 pom.xml 中引入 Jakarta EE Web API 的依赖 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        在 Spring Web MVC 6 中，Servlet API 迁移到了 Jakarta EE API，因此在配置 DispatcherServlet 时需要使用</span></span><br><span class="line"><span class="comment">         Jakarta EE 提供的相应类库和命名空间。错误信息 “‘org.springframework.web.servlet.DispatcherServlet’</span></span><br><span class="line"><span class="comment">         is not assignable to ‘javax.servlet.Servlet,jakarta.servlet.Servlet’” 表明你使用了旧版本的</span></span><br><span class="line"><span class="comment">         Servlet API，没有更新到 Jakarta EE 规范。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- springwebmvc相关依赖  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Controller声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//handlers</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handler就是controller内部的具体方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@RequestMapping</span>(&quot;/springmvc/hello&quot;) 就是用来向handlerMapping中注册的方法注解!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ResponseBody</span> 代表向浏览器直接返回数据!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/springmvc/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloController.hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello springmvc!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>SpringIoC配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wzb.controller&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 方案1: 手动配置handlerMapping 和 handlerAdapter --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- handlerMapping</span></span><br><span class="line"><span class="comment">         RequestMappingHandlerMapping 就是springmvc提供的组件</span></span><br><span class="line"><span class="comment">         支持@RequestMapping方式注册的handler</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- handlerAdapter</span></span><br><span class="line"><span class="comment">         RequestMappingHandlerAdapter 就是springmvc提供的组件</span></span><br><span class="line"><span class="comment">         支持@RequestMapping方式注册的handler</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方案2: 不配置</span></span><br><span class="line"><span class="comment">         解释: springmvc会在启动的时候,如果发现我们没有配置handlerMapping,handlerAdapter,viewResolver</span></span><br><span class="line"><span class="comment">         就会加载spring-webmvc包下的配置DispatcherServlet.properties下的组件!</span></span><br><span class="line"><span class="comment">         DispatcherServlet.properties:</span></span><br><span class="line"><span class="comment">           org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span></span><br><span class="line"><span class="comment">                org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\</span></span><br><span class="line"><span class="comment">                org.springframework.web.servlet.function.support.RouterFunctionMapping</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span></span><br><span class="line"><span class="comment">                org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span></span><br><span class="line"><span class="comment">                org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter,\</span></span><br><span class="line"><span class="comment">                org.springframework.web.servlet.function.support.HandlerFunctionAdapter</span></span><br><span class="line"><span class="comment">            ........</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         所以,我们可以不同写,也会默认加载! 注意: 一旦你配置了,就不会加载对应的默认组件切记!!!</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- viewResolver 不需要配置,因为我们不需要查找逻辑视图!!! --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br></pre></td></tr></table></figure>
</li>
<li><p>web.xml配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置SpringMVC中负责处理请求的核心Servlet，也被称为SpringMVC的前端控制器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- DispatcherServlet的全类名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 如果不记得contextConfigLocation配置项的名称，可以到DispatcherServlet的父类FrameworkServlet中查找 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 使用classpath:说明这个路径从类路径的根目录开始才查找 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 作为框架的核心组件，在启动过程中有大量的初始化操作要做，这些操作放在第一次请求时才执行非常不恰当 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们应该将DispatcherServlet设置为随Web应用一起启动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>100<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对DispatcherServlet来说，url-pattern有两种方式配置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置“/”，表示匹配整个Web应用范围内所有请求。这里有一个硬性规定：不能写成“/*”。</span></span><br><span class="line"><span class="comment">      只有这一个地方有这个特殊要求，以后我们再配置Filter还是可以正常写“/*”。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动测试</p>
<p>注意： tomcat应该是10+版本！方可支持 Jakarta EE API!</p>
<p>![](Spring MVC控制层框架&#x2F;image_RmY8VOdQnq.png)</p>
</li>
</ol>
<h2 id="二、SpringMVC接收数据"><a href="#二、SpringMVC接收数据" class="headerlink" title="二、SpringMVC接收数据"></a>二、SpringMVC接收数据</h2><h3 id="1-访问路径设置"><a href="#1-访问路径设置" class="headerlink" title="1. 访问路径设置"></a>1. 访问路径设置</h3><p>@RequestMapping注解的作用就是将请求的 URL 地址和处理请求的方式（handler方法）关联起来，建立映射关系。</p>
<p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。</p>
<ol>
<li><p><strong>精准路径匹配</strong></p>
<p>在@RequestMapping注解指定 URL 地址时，不使用任何通配符，按照请求地址进行精确匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/login</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/register</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/register&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.register&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>模糊路径匹配</strong></p>
<p>在@RequestMapping注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  路径设置为 /product/*  </span></span><br><span class="line"><span class="comment">     *    /* 为单层任意字符串  /product/a  /product/aaa 可以访问此handler  </span></span><br><span class="line"><span class="comment">     *    /product/a/a 不可以</span></span><br><span class="line"><span class="comment">     *  路径设置为 /product/** </span></span><br><span class="line"><span class="comment">     *   /** 为任意层任意字符串  /product/a  /product/aaa 可以访问此handler  </span></span><br><span class="line"><span class="comment">     *   /product/a/a 也可以访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/product/*&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProductController.show&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;product show!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">单层匹配和多层匹配：</span><br><span class="line">  /*：只能匹配URL地址中的一层，如果想准确匹配两层，那么就写“/*/*”以此类推。</span><br><span class="line">  /**：可以匹配URL地址中的多层。</span><br><span class="line">其中所谓的一层或多层是指一个URL地址字符串被“/”划分出来的各个层次</span><br><span class="line">这个知识点虽然对于@RequestMapping注解来说实用性不大，但是将来配置拦截器的时候也遵循这个规则。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类和方法级别区别</strong></p>
<p><code>@RequestMapping</code> 注解可以用于类级别和方法级别，它们之间的区别如下：</p>
<ol>
<li>设置到类级别：<code>@RequestMapping</code> 注解可以设置在控制器类上，用于映射整个控制器的通用请求路径。这样，如果控制器中的多个方法都需要映射同一请求路径，就不需要在每个方法上都添加映射路径。</li>
<li>设置到方法级别：<code>@RequestMapping</code> 注解也可以单独设置在控制器方法上，用于更细粒度地映射请求路径和处理方法。当多个方法处理同一个路径的不同操作时，可以使用方法级别的 <code>@RequestMapping</code> 注解进行更精细的映射。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.标记到handler方法</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/register&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/logout&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.优化标记类+handler方法</span></span><br><span class="line"><span class="comment">//类上</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//handler方法上</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/logout&quot;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>附带请求方式限制</strong></p>
<p>HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMethod</span> &#123;</span><br><span class="line">  GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下：@RequestMapping(“&#x2F;logout”) 任何请求方式都可以访问！</p>
<p>如果需要特定指定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/login</span></span><br><span class="line"><span class="comment">     * method = RequestMethod.POST 可以指定单个或者多个请求方式!</span></span><br><span class="line"><span class="comment">     * 注意:违背请求方式会出现405异常!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125; , method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精准设置访问地址 /user/register</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/register&quot;&#125;,method = &#123;RequestMethod.POST,RequestMethod.GET&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.register&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：违背请求方式，会出现405异常！！！</p>
</li>
<li><p><strong>进阶注解</strong></p>
<p>还有 <code>@RequestMapping</code> 的 HTTP 方法特定快捷方式变体：</p>
<ul>
<li><code>@GetMapping</code></li>
<li><code>@PostMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
<li><code>@PatchMapping</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET)</span></span><br><span class="line">||</span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/login&quot;)</span></span><br></pre></td></tr></table></figure>
<p>注意：进阶注解只能添加到handler方法上，无法添加到类上！</p>
</li>
<li><p><strong>常见配置问题</strong></p>
<p>出现原因：多个 handler 方法映射了同一个地址，导致 SpringMVC 在接收到这个地址的请求时该找哪个 handler 方法处理。</p>
<blockquote>
<p>There is already ‘demo03MappingMethodHandler’ bean method com.wzb.mvc.handler.Demo03MappingMethodHandler#empGet() <strong>mapped</strong>.</p>
</blockquote>
</li>
</ol>
<h3 id="2-接收参数（重点）"><a href="#2-接收参数（重点）" class="headerlink" title="2. 接收参数（重点）"></a>2. 接收参数（重点）</h3><h4 id="2-1-param-和-json参数比较"><a href="#2-1-param-和-json参数比较" class="headerlink" title="2.1 param 和 json参数比较"></a>2.1 param 和 json参数比较</h4><p>在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区别和对比：</p>
<ol>
<li><p>参数编码： &#x20;</p>
<p>param 类型的参数会被编码为 ASCII 码。例如，假设 <code>name=john doe</code>，则会被编码为 <code>name=john%20doe</code>。而 JSON 类型的参数会被编码为 UTF-8。</p>
</li>
<li><p>参数顺序： &#x20;</p>
<p>param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。</p>
</li>
<li><p>数据类型： &#x20;</p>
<p>param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。</p>
</li>
<li><p>嵌套性： &#x20;</p>
<p>param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。</p>
</li>
<li><p>可读性： &#x20;</p>
<p>param 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。</p>
</li>
</ol>
<p>总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。</p>
<h4 id="2-2-param参数接收"><a href="#2-2-param参数接收" class="headerlink" title="2.2 param参数接收"></a>2.2 param参数接收</h4><ol>
<li><p><strong>直接接值</strong></p>
<p>客户端请求</p>
<p>![](Spring MVC控制层框架&#x2F;image_plXEAfszjM.png)</p>
<p>handler接收参数</p>
<p>只要形参数名和类型与传递参数相同，即可自动接收!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 可以利用形参列表,直接接收前端传递的param参数!</span></span><br><span class="line"><span class="comment">     *    要求: 参数名 = 形参名</span></span><br><span class="line"><span class="comment">     *          类型相同</span></span><br><span class="line"><span class="comment">     * 出现乱码正常，json接收具体解决！！</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回前端数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value=&quot;/value&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setupForm</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> name + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>@RequestParam注解</strong></p>
<p>可以使用 <code>@RequestParam</code> 注释将 Servlet 请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。</p>
<p><code>@RequestParam</code>使用场景：</p>
<ul>
<li>指定绑定的请求参数名</li>
<li>要求请求参数必须传递</li>
<li>为请求参数提供默认值<br>基本用法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  使用<span class="doctag">@RequestParam</span>注解标记handler方法的形参</span></span><br><span class="line"><span class="comment"> *  指定形参对应的请求参数<span class="doctag">@RequestParam</span>(请求参数名称)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">paramForm</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(&quot;stuAge&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，使用此批注的方法参数是必需的，但您可以通过将 <code>@RequestParam</code> 批注的 <code>required</code> 标志设置为 <code>false</code>！</p>
<p>如果没有没有设置非必须，也没有传递参数会出现：</p>
<p>![](Spring MVC控制层框架&#x2F;image_ckLWLe8fG6.png)</p>
<p>将参数设置非必须，并且设置默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">paramForm</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(value = &quot;stuAge&quot;,required = false,defaultValue = &quot;18&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>特殊场景接值</strong></p>
<ol>
<li><p>一名多值</p>
<p>多选框，提交的数据的时候一个key对应多个值，我们可以使用集合进行接收！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  一名多值,可以使用集合接收即可!但是需要使用<span class="doctag">@RequestParam</span>注解指定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/mul&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">mulForm</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; hbs)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hbs = &quot;</span> + hbs);</span><br><span class="line">    <span class="keyword">return</span> hbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实体接收</p>
<p>Spring MVC 是 Spring 框架提供的 Web 框架，它允许开发者使用实体对象来接收 HTTP 请求中的参数。通过这种方式，可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。下面是一个使用实体对象接收参数的示例：</p>
<p>定义一个用于接收参数的实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter 和 setter 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在控制器中，使用实体对象接收，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里可以使用 user 对象的属性来接收请求参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名！否则无法映射！</p>
<p>使用postman传递参数测试：</p>
<p>![](Spring MVC控制层框架&#x2F;image_LvGYFzl7Ij.png)</p>
</li>
</ol>
</li>
</ol>
<h4 id="2-3-路径-参数接收"><a href="#2-3-路径-参数接收" class="headerlink" title="2.3 路径 参数接收"></a>2.3 路径 参数接收</h4><p>路径传递参数是一种在 URL 路径中传递参数的方式。在 RESTful 的 Web 应用程序中，经常使用路径传递参数来表示资源的唯一标识符或更复杂的表示方式。而 Spring MVC 框架提供了 <code>@PathVariable</code> 注解来处理路径传递参数。</p>
<p><code>@PathVariable</code> 注解允许将 URL 中的占位符映射到控制器方法中的参数。</p>
<p>例如，如果我们想将 <code>/user/{id}</code> 路径下的 <code>{id}</code> 映射到控制器方法的一个参数中，则可以使用 <code>@PathVariable</code> 注解来实现。</p>
<p>下面是一个使用 <code>@PathVariable</code> 注解处理路径传递参数的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态路径设计: /user/&#123;动态部分&#125;/&#123;动态部分&#125;   动态部分使用&#123;&#125;包含即可! &#123;&#125;内部动态标识!</span></span><br><span class="line"><span class="comment"> * 形参列表取值: <span class="doctag">@PathVariable</span> Long id  如果形参名 = &#123;动态标识&#125; 自动赋值!</span></span><br><span class="line"><span class="comment"> *              <span class="doctag">@PathVariable</span>(&quot;动态标识&quot;) Long id  如果形参名 != &#123;动态标识&#125; 可以通过指定动态标识赋值!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 访问测试:  /param/user/1/root  -&gt; id = 1  uname = root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id, </span></span><br><span class="line"><span class="params">                      <span class="meta">@PathVariable(&quot;name&quot;)</span> String uname)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id = &quot;</span> + id + <span class="string">&quot;, uname = &quot;</span> + uname);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user_detail&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-json参数接收"><a href="#2-4-json参数接收" class="headerlink" title="2.4 json参数接收"></a>2.4 json参数接收</h4><p>前端传递 JSON 数据时，Spring MVC 框架可以使用 <code>@RequestBody</code> 注解来将 JSON 数据转换为 Java 对象。<code>@RequestBody</code> 注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value 属性来指示请求体应该映射到哪个参数上。其使用方式和示例代码如下：</p>
<ol>
<li><p>前端发送 JSON 数据的示例：（使用postman测试）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;男&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个用于接收 JSON 数据的 Java 类，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String gender;</span><br><span class="line">  <span class="comment">// getter 和 setter 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在控制器中，使用 <code>@RequestBody</code> 注解来接收 JSON 数据，并将其转换为 Java 对象，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addPerson</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里可以使用 person 对象来操作 JSON 数据中包含的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>@RequestBody</code> 注解将请求体中的 JSON 数据映射到 <code>Person</code> 类型的 <code>person</code> 参数上，并将其作为一个对象来传递给 <code>addPerson()</code> 方法进行处理。</p>
</li>
<li><p>完善配置</p>
<p>测试：</p>
<p>![](Spring MVC控制层框架&#x2F;image_XLO-MAnues.png)</p>
<p>问题：</p>
<p>org.springframework.web.HttpMediaTypeNotSupportedException: Content-Type ‘application&#x2F;json;charset&#x3D;UTF-8’ is not supported]</p>
<p>![](Spring MVC控制层框架&#x2F;image_T1gLO4uFgn.png)</p>
<p>原因：</p>
<ul>
<li>不支持json数据类型处理</li>
<li>没有json类型处理的工具（jackson）<br>解决：<br>spring-mvc.xml 配置json转化器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wzb.controller&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">       注意: 导入mvc命名空间!</span></span><br><span class="line"><span class="comment">       mvc:annotation-driven 是一个整合标签</span></span><br><span class="line"><span class="comment">                             他会导入handlerMapping和handlerAdapter</span></span><br><span class="line"><span class="comment">                             他会导入json数据格式转化器等等!</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- viewResolver 不需要配置,因为我们不需要查找逻辑视图!!! --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>pom.xml 加入jackson依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mvc:annotation说明</p>
<p>&lt;mvc:annotation是一个整合配置标签，一个标签将springmvc必备组件都加入到ioc容器中！其中包含handlerMapping和handlerAdapter以及json转化器等等！</p>
<p>让我们来查看下&lt;mvc:annotation具体的动作！</p>
<ul>
<li><p>先查看&lt;mvc:annotation标签最终对应解析的Java类</p>
<p>![](Spring MVC控制层框架&#x2F;image_eU-869Kx3r.png)</p>
</li>
<li><p>查看解析类中具体的动作即可</p>
<p>打开源码：org.springframework.web.servlet.config.MvcNamespaceHandler</p>
<p>![](Spring MVC控制层框架&#x2F;image_zxx3CTng-X.png)</p>
<p>打开源码：org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnnotationDrivenBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionParser</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HANDLER_MAPPING_BEAN_NAME</span> <span class="operator">=</span> RequestMappingHandlerMapping.class.getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HANDLER_ADAPTER_BEAN_NAME</span> <span class="operator">=</span> RequestMappingHandlerAdapter.class.getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> AnnotationDrivenBeanDefinitionParser.class.getClassLoader();</span><br><span class="line">    javaxValidationPresent = ClassUtils.isPresent(<span class="string">&quot;jakarta.validation.Validator&quot;</span>, classLoader);</span><br><span class="line">    romePresent = ClassUtils.isPresent(<span class="string">&quot;com.rometools.rome.feed.WireFeed&quot;</span>, classLoader);</span><br><span class="line">    jaxb2Present = ClassUtils.isPresent(<span class="string">&quot;jakarta.xml.bind.Binder&quot;</span>, classLoader);</span><br><span class="line">    jackson2Present = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;</span>, classLoader) &amp;&amp;</span><br><span class="line">            ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.core.JsonGenerator&quot;</span>, classLoader);</span><br><span class="line">    jackson2XmlPresent = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;</span>, classLoader);</span><br><span class="line">    jackson2SmilePresent = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.dataformat.smile.SmileFactory&quot;</span>, classLoader);</span><br><span class="line">    jackson2CborPresent = ClassUtils.isPresent(<span class="string">&quot;com.fasterxml.jackson.dataformat.cbor.CBORFactory&quot;</span>, classLoader);</span><br><span class="line">    gsonPresent = ClassUtils.isPresent(<span class="string">&quot;com.google.gson.Gson&quot;</span>, classLoader);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext context)</span> &#123;</span><br><span class="line">        <span class="comment">//handlerMapping加入到ioc容器</span></span><br><span class="line">        readerContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME, handlerMappingDef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加jackson转化器</span></span><br><span class="line">        addRequestBodyAdvice(handlerAdapterDef);</span><br><span class="line">        addResponseBodyAdvice(handlerAdapterDef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//handlerAdapter加入到ioc容器</span></span><br><span class="line">        readerContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME, handlerAdapterDef);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体添加jackson转化对象方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addRequestBodyAdvice</span><span class="params">(RootBeanDefinition beanDef)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jackson2Present) &#123;</span><br><span class="line">            beanDef.getPropertyValues().add(<span class="string">&quot;requestBodyAdvice&quot;</span>,</span><br><span class="line">                                            <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(JsonViewRequestBodyAdvice.class));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResponseBodyAdvice</span><span class="params">(RootBeanDefinition beanDef)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jackson2Present) &#123;</span><br><span class="line">            beanDef.getPropertyValues().add(<span class="string">&quot;responseBodyAdvice&quot;</span>,</span><br><span class="line">                                            <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(JsonViewResponseBodyAdvice.class));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="3-接收Cookie数据"><a href="#3-接收Cookie数据" class="headerlink" title="3. 接收Cookie数据"></a>3. 接收Cookie数据</h3><p>可以使用 <code>@CookieValue</code> 注释将 HTTP Cookie 的值绑定到控制器中的方法参数。</p>
<p>考虑使用以下 cookie 的请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</span><br></pre></td></tr></table></figure>

<p>下面的示例演示如何获取 cookie 值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span> &#123; </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-接收请求头数据"><a href="#4-接收请求头数据" class="headerlink" title="4. 接收请求头数据"></a>4. 接收请求头数据</h3><p>可以使用 <code>@RequestHeader</code> 批注将请求标头绑定到控制器中的方法参数。</p>
<p>请考虑以下带有标头的请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Host                    localhost:<span class="number">8080</span></span><br><span class="line">Accept                  text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span></span><br><span class="line">Accept-Language         fr,en-gb;q=<span class="number">0.7</span>,en;q=<span class="number">0.3</span></span><br><span class="line">Accept-Encoding         gzip,deflate</span><br><span class="line">Accept-Charset          ISO-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>;q=<span class="number">0.7</span>,*;q=<span class="number">0.7</span></span><br><span class="line">Keep-Alive              <span class="number">300</span></span><br></pre></td></tr></table></figure>

<p>下面的示例获取 <code>Accept-Encoding</code> 和 <code>Keep-Alive</code> 标头的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding, </span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class="type">long</span> keepAlive)</span> &#123; </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-原生Api对象操作"><a href="#5-原生Api对象操作" class="headerlink" title="5. 原生Api对象操作"></a>5. 原生Api对象操作</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html">https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html</a></p>
<p>下表描述了支持的控制器方法参数</p>
<table>
<thead>
<tr>
<th>Controller method argument 控制器方法参数</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>jakarta.servlet.ServletRequest</code>, <code>jakarta.servlet.ServletResponse</code></td>
<td>请求&#x2F;响应对象</td>
</tr>
<tr>
<td><code>jakarta.servlet.http.HttpSession</code></td>
<td>强制存在会话。因此，这样的参数永远不会为 <code>null</code> 。</td>
</tr>
<tr>
<td><code>java.io.InputStream</code>, <code>java.io.Reader</code></td>
<td>用于访问由 Servlet API 公开的原始请求正文。</td>
</tr>
<tr>
<td><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td>
<td>用于访问由 Servlet API 公开的原始响应正文。</td>
</tr>
<tr>
<td><code>@PathVariable</code></td>
<td>接收路径参数注解</td>
</tr>
<tr>
<td><code>@RequestParam</code></td>
<td>用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。</td>
</tr>
<tr>
<td><code>@RequestHeader</code></td>
<td>用于访问请求标头。标头值将转换为声明的方法参数类型。</td>
</tr>
<tr>
<td><code>@CookieValue</code></td>
<td>用于访问Cookie。Cookie 值将转换为声明的方法参数类型。</td>
</tr>
<tr>
<td><code>@RequestBody</code></td>
<td>用于访问 HTTP 请求正文。正文内容通过使用 <code>HttpMessageConverter</code> 实现转换为声明的方法参数类型。</td>
</tr>
<tr>
<td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td>
<td>共享域对象，并在视图呈现过程中向模板公开。</td>
</tr>
<tr>
<td><code>Errors</code>, <code>BindingResult</code></td>
<td>验证和数据绑定中的错误信息获取对象！</td>
</tr>
</tbody></table>
<p>获取原生对象示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序!</span></span><br><span class="line"><span class="comment"> * 注意: 接收原生对象,并不影响参数接收!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;api&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">api</span><span class="params">(HttpSession session , HttpServletRequest request,</span></span><br><span class="line"><span class="params">                  HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">    System.out.println(<span class="string">&quot;method = &quot;</span> + method);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;api&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-共享域对象操作"><a href="#6-共享域对象操作" class="headerlink" title="6. 共享域对象操作"></a>6. 共享域对象操作</h3><h4 id="6-1-属性（共享）域作用回顾"><a href="#6-1-属性（共享）域作用回顾" class="headerlink" title="6.1 属性（共享）域作用回顾"></a>6.1 属性（共享）域作用回顾</h4><p>在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：<code>ServletContext</code>、<code>HttpSession</code>、<code>HttpServletRequest</code>、<code>PageContext</code>。</p>
<ol>
<li><code>ServletContext</code> 共享域：<code>ServletContext</code> 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在 <code>ServletContext</code> 中保存的数据是线程安全的。</li>
<li><code>HttpSession</code> 共享域：<code>HttpSession</code> 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 <code>HttpSession</code> 中，让用户在多个页面间保持登录状态。</li>
<li><code>HttpServletRequest</code> 共享域：<code>HttpServletRequest</code> 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 <code>HttpServletRequest</code> 中，让处理器方法之间可以访问这些数据。</li>
<li><code>PageContext</code> 共享域：<code>PageContext</code> 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括<code>pageScope</code>、<code>requestScope</code>、<code>sessionScope</code>、<code>applicationScope</code> 等作用域。</li>
</ol>
<p>共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。</p>
<p>![](Spring MVC控制层框架&#x2F;img010_ORhRMPYJ9v.png)</p>
<h4 id="6-2-Request级别属性（共享）域"><a href="#6-2-Request级别属性（共享）域" class="headerlink" title="6.2 Request级别属性（共享）域"></a>6.2 Request级别属性（共享）域</h4><ol>
<li>使用 Model 类型的形参<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModel</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 在形参位置声明Model类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">        Model model)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line">    <span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;requestScopeMessageModel&quot;</span>,<span class="string">&quot;i am very happy[model]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 ModelMap 类型的形参<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModelMap</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 在形参位置声明ModelMap类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">        ModelMap modelMap)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line">    <span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;requestScopeMessageModelMap&quot;</span>,<span class="string">&quot;i am very happy[model map]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 Map 类型的形参<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestMap</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 在形参位置声明Map类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">        Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line">    <span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">    map.put(<span class="string">&quot;requestScopeMessageMap&quot;</span>, <span class="string">&quot;i am very happy[map]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用原生 request 对象<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/original&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrOriginalRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 拿到原生对象，就可以调用原生方法执行各种操作</span></span><br><span class="line"><span class="params">        HttpServletRequest request)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    request.setAttribute(<span class="string">&quot;requestScopeMessageOriginal&quot;</span>, <span class="string">&quot;i am very happy[original]&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 ModelAndView 对象<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/mav&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testAttrByModelAndView</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建ModelAndView对象</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">// 2.存入模型数据</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;requestScopeMessageMAV&quot;</span>, <span class="string">&quot;i am very happy[mav]&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.设置视图名称</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;target&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="6-3-Session级别属性（共享）域"><a href="#6-3-Session级别属性（共享）域" class="headerlink" title="6.3 Session级别属性（共享）域"></a>6.3 Session级别属性（共享）域</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/session&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrSession</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//直接对session对象操作,即对会话范围操作!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-Application级别属性（共享）域"><a href="#6-4-Application级别属性（共享）域" class="headerlink" title="6.4 Application级别属性（共享）域"></a>6.4 Application级别属性（共享）域</h4><p>解释：springmvc会在初始化容器的时候，讲servletContext对象存储到ioc容器中！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/attr/application&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">attrApplication</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    servletContext.setAttribute(<span class="string">&quot;appScopeMsg&quot;</span>, <span class="string">&quot;i am hungry...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、SpringMVC响应数据"><a href="#三、SpringMVC响应数据" class="headerlink" title="三、SpringMVC响应数据"></a>三、SpringMVC响应数据</h2><h3 id="1-handler方法分析"><a href="#1-handler方法分析" class="headerlink" title="1. handler方法分析"></a>1. handler方法分析</h3><p>理解handler方法的作用和组成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 一个controller的方法是控制层的一个处理器,我们称为handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> handler需要使用<span class="doctag">@RequestMapping</span>/<span class="doctag">@GetMapping</span>系列,声明路径,在HandlerMapping中注册,供DS查找!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> handler作用总结:</span></span><br><span class="line"><span class="comment"> *       1.接收请求参数(param,json,pathVariable,共享域等) </span></span><br><span class="line"><span class="comment"> *       2.调用业务逻辑 </span></span><br><span class="line"><span class="comment"> *       3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> handler如何处理呢</span></span><br><span class="line"><span class="comment"> *       1.接收参数: handler(形参列表: 主要的作用就是用来接收参数)</span></span><br><span class="line"><span class="comment"> *       2.调用业务: &#123; 方法体  可以向后调用业务方法 service.xx() &#125;</span></span><br><span class="line"><span class="comment"> *       3.响应数据: return 返回结果,可以快速响应前端数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handler</span><span class="params">(简化请求参数接收)</span>&#123;</span><br><span class="line">    调用业务方法</span><br><span class="line">    <span class="keyword">return</span> 简化响应前端数据;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结： 请求数据接收，我们都是通过handler的形参列表</p>
<p>&#x20;            前端数据响应，我们都是通过handler的return关键字快速处理！</p>
<p>&#x20;springmvc简化了参数接收和响应！</p>
<h3 id="2-页面跳转控制"><a href="#2-页面跳转控制" class="headerlink" title="2. 页面跳转控制"></a>2. 页面跳转控制</h3><h4 id="2-1-快速返回jsp视图"><a href="#2-1-快速返回jsp视图" class="headerlink" title="2.1 快速返回jsp视图"></a>2.1 快速返回jsp视图</h4><ol>
<li><p>开发模式回顾</p>
<p>在 Web 开发中，有两种主要的开发模式：前后端分离和混合开发。</p>
<p>前后端分离模式：</p>
<p>指将前端的界面和后端的业务逻辑通过接口分离开发的一种方式。开发人员使用不同的技术栈和框架，前端开发人员主要负责页面的呈现和用户交互，后端开发人员主要负责业务逻辑和数据存储。前后端通信通过 API 接口完成，数据格式一般使用 JSON 或 XML。前后端分离模式可以提高开发效率，同时也有助于代码重用和维护。</p>
<p>混合开发模式：</p>
<p>指将前端和后端的代码集成在同一个项目中，共享相同的技术栈和框架。这种模式在小型项目中比较常见，可以减少学习成本和部署难度。但是，在大型项目中，这种模式会导致代码耦合性很高，维护和升级难度较大。</p>
<p>对于混合开发，我们就需要使用动态页面技术，动态展示Java的共享域数据！！</p>
</li>
<li><p>jsp技术了解</p>
<p>JSP（JavaServer Pages）是一种动态网页开发技术，它是由 Sun 公司提出的一种基于 Java 技术的 Web 页面制作技术，可以在 HTML 文件中嵌入 Java 代码，使得生成动态内容的编写更加简单。</p>
<p>JSP 最主要的作用是生成动态页面。它允许将 Java 代码嵌入到 HTML 页面中，以便使用 Java 进行数据库查询、处理表单数据和生成 HTML 等动态内容。另外，JSP 还可以与 Servlet 结合使用，实现更加复杂的 Web 应用程序开发。</p>
<p>JSP 的主要特点包括：</p>
<ol>
<li>简单：JSP 通过将 Java 代码嵌入到 HTML 页面中，使得生成动态内容的编写更加简单。</li>
<li>高效：JSP 首次运行时会被转换为 Servlet，然后编译为字节码，从而可以启用 Just-in-Time（JIT）编译器，实现更高效的运行。</li>
<li>多样化：JSP 支持多种标准标签库，包括 JSTL（JavaServer Pages 标准标签库）、EL（表达式语言）等，可以帮助开发人员更加方便的处理常见的 Web 开发需求。<br>总之，JSP 是一种简单高效、多样化的动态网页开发技术，它可以方便地生成动态页面和与 Servlet 结合使用，是 Java Web 开发中常用的技术之一。</li>
</ol>
</li>
<li><p>准备jsp页面和依赖</p>
<p>pom.xml依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jsp需要依赖! jstl--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet.jsp.jstl-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>jsp页面创建</p>
<p>建议位置：&#x2F;WEB-INF&#x2F;下，避免外部直接访问！</p>
<p>位置：&#x2F;WEB-INF&#x2F;views&#x2F;home.jsp</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">        &lt;!-- 可以获取共享域的数据,动态展示! jsp== 后台vue --&gt;</span><br><span class="line">        $&#123;msg&#125;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>快速响应模版页面</p>
<ol>
<li><p>配置jsp视图解析器</p>
<p>springmvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置动态页面语言jsp的视图解析器,快速查找jsp--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/views/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>handler返回视图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  跳转到提交文件页面  /save/jump</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  如果要返回jsp页面!</span></span><br><span class="line"><span class="comment"> *     1.方法返回值改成字符串类型</span></span><br><span class="line"><span class="comment"> *     2.返回逻辑视图名即可    </span></span><br><span class="line"><span class="comment"> *         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt;</span></span><br><span class="line"><span class="comment"> *            + 逻辑视图名 +</span></span><br><span class="line"><span class="comment"> *         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;jump&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jumpJsp</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;FileController.jumpJsp&quot;</span>);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;request data!!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="2-2-转发和重定向"><a href="#2-2-转发和重定向" class="headerlink" title="2.2 转发和重定向"></a>2.2 转发和重定向</h4><p>在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用 <code>redirect</code> 或者 <code>forward</code> 关键字来实现重定向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/redirect-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">redirectDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 重定向到 /demo 路径 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/forward-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">forwardDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 转发到 /demo 路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意： 转发和重定向到项目下资源路径都是相同，都不需要添加项目根路径！填写项目下路径即可！</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>将方法的返回值，设置String类型</li>
<li>转发使用forward关键字，重定向使用redirect关键字</li>
<li>关键字: &#x2F;路径</li>
<li>注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！</li>
</ul>
<h3 id="3-返回JSON数据（重点）"><a href="#3-返回JSON数据（重点）" class="headerlink" title="3. 返回JSON数据（重点）"></a>3. 返回JSON数据（重点）</h3><h4 id="3-1-前置准备"><a href="#3-1-前置准备" class="headerlink" title="3.1 前置准备"></a>3.1 前置准备</h4><p>导入jackson依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加json数据转化器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   注意: 导入mvc命名空间!</span></span><br><span class="line"><span class="comment">   mvc:annotation-driven 是一个整合标签</span></span><br><span class="line"><span class="comment">                         他会导入handlerMapping和handlerAdapter</span></span><br><span class="line"><span class="comment">                         他会导入json数据格式转化器等等!</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-ResponseBody"><a href="#3-2-ResponseBody" class="headerlink" title="3.2 @ResponseBody"></a>3.2 @ResponseBody</h4><ol>
<li><p>方法上使用@ResponseBody</p>
<p>可以在方法上使用 <code>@ResponseBody</code>注解，用于将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端。在前后端分离的项目中使用！</p>
<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体来说，<code>@ResponseBody</code> 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。</p>
<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping(value = &quot;/user/detail&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestBody</span> User userParam)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;userParam = &quot;</span> + userParam);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">    <span class="comment">//返回的对象,会使用jackson的序列化工具,转成json返回给前端!</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<p>![](Spring MVC控制层框架&#x2F;image_hPJueYv109.png)</p>
</li>
<li><p>类上使用@ResponseBody</p>
<p>如果类中每个方法上都标记了 @ResponseBody 注解，那么这些注解就可以提取到类上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span>  <span class="comment">//responseBody可以添加到类上,代表默认类中的所有方法都生效!</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-3-RestController"><a href="#3-3-RestController" class="headerlink" title="3.3 @RestController"></a>3.3 @RestController</h4><p>类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解。</p>
<p>RestController源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">   * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 4.0.1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@AliasFor(annotation = Controller.class)</span></span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-返回静态资源处理"><a href="#4-返回静态资源处理" class="headerlink" title="4. 返回静态资源处理"></a>4. 返回静态资源处理</h3><ol>
<li><p><strong>静态资源概念</strong></p>
<p>资源本身已经是可以直接拿到浏览器上使用的程度了，<strong>不需要在服务器端做任何运算、处理</strong>。典型的静态资源包括：</p>
<ul>
<li>纯HTML文件</li>
<li>图片</li>
<li>CSS文件</li>
<li>JavaScript文件</li>
<li>……</li>
</ul>
</li>
<li><p><strong>静态资源访问和问题解决</strong></p>
<ul>
<li><p>web应用加入静态资源</p>
<p>![](Spring MVC控制层框架&#x2F;image_4C0oYuW6p5.png)</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>手动构建确保编译</p>
<p>![](Spring MVC控制层框架&#x2F;image_rlTcHF-Uge.png)</p>
<p>![](Spring MVC控制层框架&#x2F;image_nJdal6tcLm.png)</p>
<pre><code>![](Spring MVC控制层框架/image_wsWSmj8Yfr.png)
</code></pre>
<ul>
<li><p>访问静态资源</p>
<p>![](Spring MVC控制层框架&#x2F;image_j2NW4C8FO9.png)</p>
</li>
<li><p>问题分析</p>
<ul>
<li>DispatcherServlet 的 url-pattern 配置的是“&#x2F;”</li>
<li>url-pattern 配置“&#x2F;”表示整个 Web 应用范围内所有请求都由 SpringMVC 来处理</li>
</ul>
</li>
<li><p>对 SpringMVC 来说，必须有对应的 @RequestMapping 才能找到处理请求的方法</p>
<ul>
<li>现在 images&#x2F;mi.jpg 请求没有对应的 @RequestMapping 所以返回 404</li>
</ul>
</li>
<li><p>问题解决</p>
<p>在 SpringMVC 配置文件中增加配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wzb.controller&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加入这个配置，SpringMVC 就会在遇到没有 @RequestMapping 的请求时放它过去 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 所谓放它过去就是让这个请求去找它原本要访问的资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再次测试访问图片：</p>
<p>![](Spring MVC控制层框架&#x2F;image_Hi-upkttjY.png)</p>
<p>新的问题：其他原本正常的handler请求访问不了了</p>
<p>handler无法访问</p>
<p>解决方案：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启 SpringMVC 的注解驱动功能。这个配置也被称为 SpringMVC 的标配。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 标配：因为 SpringMVC 环境下非常多的功能都要求必须打开注解驱动才能正常工作。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="四、RESTFul风格设计"><a href="#四、RESTFul风格设计" class="headerlink" title="四、RESTFul风格设计"></a>四、RESTFul风格设计</h2><h3 id="1-RESTFul风格概述"><a href="#1-RESTFul风格概述" class="headerlink" title="1. RESTFul风格概述"></a>1. RESTFul风格概述</h3><h4 id="1-1-RESTFul风格简介"><a href="#1-1-RESTFul风格简介" class="headerlink" title="1.1 RESTFul风格简介"></a>1.1 RESTFul风格简介</h4><p>![](Spring MVC控制层框架&#x2F;image_e-dNiN_-8D.png)</p>
<p>RESTful（Representational State Transfer）是一种软件架构风格，用于设计网络应用程序和服务之间的通信。它是一种基于标准 HTTP 方法的简单和轻量级的通信协议，广泛应用于现代的Web服务开发。</p>
<p>通过遵循 RESTful 架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web 服务。RESTful API 的特点是简单、清晰，并且易于使用和理解，它们使用标准的 HTTP 方法和状态码进行通信，不需要额外的协议和中间件。</p>
<p>RESTful 架构通常用于构建 Web API，提供数据的传输和操作。它可以用于各种应用场景，包括客户端-服务器应用、单页应用（SPA）、移动应用程序和微服务架构等。</p>
<p>总而言之，RESTful 是一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序！</p>
<p>![](Spring MVC控制层框架&#x2F;image_xHIbi73wr9.png)</p>
<p>学习RESTful设计原则可以帮助我们更好去设计HTTP协议的API接口！！</p>
<h4 id="1-2-RESTFul风格特点"><a href="#1-2-RESTFul风格特点" class="headerlink" title="1.2 RESTFul风格特点"></a>1.2 RESTFul风格特点</h4><ol>
<li><p>每一个URI代表1种资源（URI 是名词）；</p>
</li>
<li><p>客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</p>
</li>
<li><p>资源的表现形式是XML或者<strong>JSON</strong>；</p>
</li>
<li><p>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</p>
</li>
<li><p>小结：rest 面向的是资源、而不是功能；rest操作要求符合幂等性</p>
<pre><code>       幂等性：执行一次操作和执行多次操作对系统的影响是一样的
</code></pre>
</li>
</ol>
<h4 id="1-3-RESTFul风格设计规范"><a href="#1-3-RESTFul风格设计规范" class="headerlink" title="1.3 RESTFul风格设计规范"></a>1.3 <strong>RESTFul风格设计规范</strong></h4><ol>
<li><p><strong>HTTP协议请求方式要求</strong></p>
<p>REST 风格主张在项目设计、开发过程中，具体的操作符合<strong>HTTP协议定义的请求方式的语义</strong>。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>请求方式</th>
</tr>
</thead>
<tbody><tr>
<td>查询操作</td>
<td>GET</td>
</tr>
<tr>
<td>保存操作</td>
<td>POST</td>
</tr>
<tr>
<td>删除操作</td>
<td>DELETE</td>
</tr>
<tr>
<td>更新操作</td>
<td>PUT</td>
</tr>
</tbody></table>
</li>
<li><p><strong>URL路径风格要求</strong></p>
<p>REST风格下每个资源都应该有一个唯一的标识符，例如一个 URI（统一资源标识符）或者一个 URL（统一资源定位符）。资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！</p>
<p>使用URL+请求方式确定具体的动作，他也是一种标准的HTTP协议请求！</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>传统风格</th>
<th>REST 风格</th>
</tr>
</thead>
<tbody><tr>
<td>保存</td>
<td>&#x2F;CRUD&#x2F;saveEmp</td>
<td>URL 地址：&#x2F;emp&#xA;请求方式：POST</td>
</tr>
<tr>
<td>删除</td>
<td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td>
<td>URL 地址：&#x2F;emp&#x2F;2&#xA;请求方式：DELETE</td>
</tr>
<tr>
<td>更新</td>
<td>&#x2F;CRUD&#x2F;updateEmp</td>
<td>URL 地址：&#x2F;emp&#xA;请求方式：PUT</td>
</tr>
<tr>
<td>查询</td>
<td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td>
<td>URL 地址：&#x2F;emp&#x2F;2&#xA;请求方式：GET</td>
</tr>
</tbody></table>
</li>
</ol>
<ul>
<li><p>总结</p>
<p>根据接口的具体动作，选择具体的HTTP协议请求方式</p>
<p>路径设计从原来携带动标识，改成名词，对应资源的唯一标识即可！</p>
</li>
</ul>
<h4 id="1-4-RESTFul风格好处"><a href="#1-4-RESTFul风格好处" class="headerlink" title="1.4 RESTFul风格好处"></a>1.4 RESTFul风格好处</h4><ol>
<li><p>含蓄，安全</p>
<p>使用问号键值对的方式给服务器传递数据太明显，容易被人利用来对系统进行破坏。使用 REST 风格携带数据不再需要明显的暴露数据的名称。</p>
</li>
<li><p>风格统一</p>
<p>URL 地址整体格式统一，从前到后始终都使用斜杠划分各个单词，用简单一致的格式表达语义。</p>
</li>
<li><p>无状态</p>
<p>在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了系统设计的复杂度。</p>
</li>
<li><p>严谨，规范</p>
<p>严格按照 HTTP1.1 协议中定义的请求方式本身的语义进行操作。</p>
</li>
<li><p>简洁，优雅</p>
<p>过去做增删改查操作需要设计4个不同的URL，现在一个就够了。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>传统风格</th>
<th>REST 风格</th>
</tr>
</thead>
<tbody><tr>
<td>保存</td>
<td>&#x2F;CRUD&#x2F;saveEmp</td>
<td>URL 地址：&#x2F;emp&#xA;请求方式：POST</td>
</tr>
<tr>
<td>删除</td>
<td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td>
<td>URL 地址：&#x2F;emp&#x2F;2&#xA;请求方式：DELETE</td>
</tr>
<tr>
<td>更新</td>
<td>&#x2F;CRUD&#x2F;updateEmp</td>
<td>URL 地址：&#x2F;emp&#xA;请求方式：PUT</td>
</tr>
<tr>
<td>查询</td>
<td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td>
<td>URL 地址：&#x2F;emp&#x2F;2&#xA;请求方式：GET</td>
</tr>
</tbody></table>
</li>
<li><p>丰富的语义</p>
<p>通过 URL 地址就可以知道资源之间的关系。它能够把一句话中的很多单词用斜杠连起来，反过来说就是可以在 URL 地址中用一句话来充分表达语义。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/shop" title="http:&#x2F;&#x2F;localhost:8080&#x2F;shop">http://localhost:8080/shop</a> <a target="_blank" rel="noopener" href="http://localhost:8080/shop/product" title="http:&#x2F;&#x2F;localhost:8080&#x2F;shop&#x2F;product">http://localhost:8080/shop/product</a> <a target="_blank" rel="noopener" href="http://localhost:8080/shop/product/cellPhone" title="http:&#x2F;&#x2F;localhost:8080&#x2F;shop&#x2F;product&#x2F;cellPhone">http://localhost:8080/shop/product/cellPhone</a> <a target="_blank" rel="noopener" href="http://localhost:8080/shop/product/cellPhone/iPhone" title="http:&#x2F;&#x2F;localhost:8080&#x2F;shop&#x2F;product&#x2F;cellPhone&#x2F;iPhone">http://localhost:8080/shop/product/cellPhone/iPhone</a></p>
</blockquote>
</li>
</ol>
<h3 id="2-RESTFul风格实战"><a href="#2-RESTFul风格实战" class="headerlink" title="2. RESTFul风格实战"></a>2. RESTFul风格实战</h3><h4 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h4><ul>
<li>数据结构： User {id 唯一标识,name 用户名，age 用户年龄}</li>
<li>功能分析<ul>
<li>用户数据分页展示功能（条件：page 页数 默认1，size 每页数量 默认 10）</li>
<li>保存用户功能</li>
<li>根据用户id查询用户详情功能</li>
<li>根据用户id更新用户数据功能</li>
<li>根据用户id删除用户数据功能</li>
<li>多条件模糊查询用户功能（条件：keyword 模糊关键字，page 页数 默认1，size 每页数量 默认 10）</li>
</ul>
</li>
</ul>
<h4 id="2-2-RESTFul风格接口设计"><a href="#2-2-RESTFul风格接口设计" class="headerlink" title="2.2 RESTFul风格接口设计"></a>2.2 RESTFul风格接口设计</h4><ol>
<li><p><strong>接口设计</strong></p>
<table>
<thead>
<tr>
<th>功能</th>
<th>接口和请求方式</th>
<th>请求参数</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>分页查询</td>
<td>GET  &#x2F;user</td>
<td>page&#x3D;1&amp;size&#x3D;10 param</td>
<td>{ 响应数据 }</td>
</tr>
<tr>
<td>用户添加</td>
<td>POST &#x2F;user</td>
<td>{ user 数据 }</td>
<td>{响应数据}</td>
</tr>
<tr>
<td>用户详情</td>
<td>GET &#x2F;user&#x2F;1</td>
<td>路径参数</td>
<td>{响应数据}</td>
</tr>
<tr>
<td>用户更新</td>
<td>PUT &#x2F;user</td>
<td>{ user 更新数据}</td>
<td>{响应数据}</td>
</tr>
<tr>
<td>用户删除</td>
<td>DELETE &#x2F;user&#x2F;1</td>
<td>路径参数</td>
<td>{响应数据}</td>
</tr>
<tr>
<td>条件模糊</td>
<td>GET &#x2F;user&#x2F;search</td>
<td>page&#x3D;1&amp;size&#x3D;10&amp;keywork&#x3D;关键字</td>
<td>{响应数据}</td>
</tr>
</tbody></table>
</li>
<li><p><strong>问题讨论</strong></p>
<p>为什么查询用户详情，就使用路径传递参数，多条件模糊查询，就使用请求参数传递？</p>
<p>误区：restful风格下，不是所有请求参数都是路径传递！可以使用其他方式传递！</p>
<p>在 RESTful API 的设计中，路径和请求参数和请求体都是用来向服务器传递信息的方式。</p>
<ul>
<li>对于查询用户详情，使用路径传递参数是因为这是一个单一资源的查询，即查询一条用户记录。使用路径参数可以明确指定所请求的资源，便于服务器定位并返回对应的资源，也符合 RESTful 风格的要求。</li>
<li>而对于多条件模糊查询，使用请求参数传递参数是因为这是一个资源集合的查询，即查询多条用户记录。使用请求参数可以通过组合不同参数来限制查询结果，路径参数的组合和排列可能会很多，不如使用请求参数更加灵活和简洁。<br>此外，还有一些通用的原则可以遵循：</li>
<li>路径参数应该用于指定资源的唯一标识或者 ID，而请求参数应该用于指定查询条件或者操作参数。</li>
<li>请求参数应该限制在 10 个以内，过多的请求参数可能导致接口难以维护和使用。</li>
<li>对于敏感信息，最好使用 POST 和请求体来传递参数。</li>
</ul>
</li>
</ol>
<h4 id="2-3-后台接口实现"><a href="#2-3-后台接口实现" class="headerlink" title="2.3 后台接口实现"></a>2.3 后台接口实现</h4><p>准备用户实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wzb.pojo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.wzb.pojo</span></span><br><span class="line"><span class="comment"> * 用户实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>准备用户Controller:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.wzb.controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * description: 用户模块的控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟分页查询业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">queryPage</span><span class="params">(<span class="meta">@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)</span><span class="type">int</span> page,</span></span><br><span class="line"><span class="params">                            <span class="meta">@RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)</span><span class="type">int</span> size)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;page = &quot;</span> + page + <span class="string">&quot;, size = &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;分页查询业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟用户保存业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户保存业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟用户详情业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">detailUser</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户详情业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟用户更新业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">updateUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户更新业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟条件分页查询业务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;search&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">queryPage</span><span class="params">(<span class="meta">@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)</span><span class="type">int</span> page,</span></span><br><span class="line"><span class="params">                            <span class="meta">@RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)</span><span class="type">int</span> size,</span></span><br><span class="line"><span class="params">                            <span class="meta">@RequestParam(name = &quot;keyword&quot;,required= false)</span>String keyword)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;page = &quot;</span> + page + <span class="string">&quot;, size = &quot;</span> + size + <span class="string">&quot;, keyword = &quot;</span> + keyword);</span><br><span class="line">        System.out.println(<span class="string">&quot;条件分页查询业务!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、基于RESTFul风格增删改查练习"><a href="#五、基于RESTFul风格增删改查练习" class="headerlink" title="五、基于RESTFul风格增删改查练习"></a>五、基于RESTFul风格增删改查练习</h2><h3 id="1-案例功能和接口分析"><a href="#1-案例功能和接口分析" class="headerlink" title="1. 案例功能和接口分析"></a>1. 案例功能和接口分析</h3><h4 id="1-1-功能预览"><a href="#1-1-功能预览" class="headerlink" title="1.1 功能预览"></a>1.1 功能预览</h4><p>![](Spring MVC控制层框架&#x2F;image_CloFbJri5w.png)</p>
<h4 id="1-2-接口分析"><a href="#1-2-接口分析" class="headerlink" title="1.2 接口分析"></a>1.2 接口分析</h4><ol>
<li>学习计划查询<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">需求说明</span></span><br><span class="line"><span class="comment">    查询全部数据页数据</span></span><br><span class="line"><span class="comment">请求uri</span></span><br><span class="line"><span class="comment">    schedule</span></span><br><span class="line"><span class="comment">请求方式 </span></span><br><span class="line"><span class="comment">    get   </span></span><br><span class="line"><span class="comment">响应的json</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        &quot;code&quot;:200,</span></span><br><span class="line"><span class="comment">        &quot;flag&quot;:true,</span></span><br><span class="line"><span class="comment">        &quot;data&quot;:[</span></span><br><span class="line"><span class="comment">            &#123;id:1,title:&#x27;学习java&#x27;,completed:true&#125;,</span></span><br><span class="line"><span class="comment">            &#123;id:2,title:&#x27;学习html&#x27;,completed:true&#125;,</span></span><br><span class="line"><span class="comment">            &#123;id:3,title:&#x27;学习css&#x27;,completed:true&#125;,</span></span><br><span class="line"><span class="comment">            &#123;id:4,title:&#x27;学习js&#x27;,completed:true&#125;,</span></span><br><span class="line"><span class="comment">            &#123;id:5,title:&#x27;学习vue&#x27;,completed:true&#125;</span></span><br><span class="line"><span class="comment">        ]</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li>学习计划删除<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">需求说明</span></span><br><span class="line"><span class="comment">    根据id删除日程</span></span><br><span class="line"><span class="comment">请求uri</span></span><br><span class="line"><span class="comment">    schedule/&#123;id&#125;</span></span><br><span class="line"><span class="comment">请求方式 </span></span><br><span class="line"><span class="comment">    delete</span></span><br><span class="line"><span class="comment">响应的json</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        &quot;code&quot;:200,</span></span><br><span class="line"><span class="comment">        &quot;flag&quot;:true,</span></span><br><span class="line"><span class="comment">        &quot;data&quot;:null</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li>学习计划保存<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">需求说明</span></span><br><span class="line"><span class="comment">    增加日程</span></span><br><span class="line"><span class="comment">请求uri</span></span><br><span class="line"><span class="comment">    schedule</span></span><br><span class="line"><span class="comment">请求方式 </span></span><br><span class="line"><span class="comment">    post</span></span><br><span class="line"><span class="comment">请求体中的JSON</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        title: &#x27;&#x27;,</span></span><br><span class="line"><span class="comment">        completed: false</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">响应的json</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        &quot;code&quot;:200,</span></span><br><span class="line"><span class="comment">        &quot;flag&quot;:true,</span></span><br><span class="line"><span class="comment">        &quot;data&quot;:null</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li>学习计划修改<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">需求说明</span></span><br><span class="line"><span class="comment">    根据id修改数据</span></span><br><span class="line"><span class="comment">请求uri</span></span><br><span class="line"><span class="comment">    schedule</span></span><br><span class="line"><span class="comment">请求方式 </span></span><br><span class="line"><span class="comment">    put</span></span><br><span class="line"><span class="comment">请求体中的JSON</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        id: 1,</span></span><br><span class="line"><span class="comment">        title: &#x27;&#x27;,</span></span><br><span class="line"><span class="comment">        completed: false</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">响应的json</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        &quot;code&quot;:200,</span></span><br><span class="line"><span class="comment">        &quot;flag&quot;:true,</span></span><br><span class="line"><span class="comment">        &quot;data&quot;:null</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-工程项目准备"><a href="#2-工程项目准备" class="headerlink" title="2. 工程项目准备"></a>2. 工程项目准备</h3><h4 id="2-1-前端项目搭建"><a href="#2-1-前端项目搭建" class="headerlink" title="2.1 前端项目搭建"></a>2.1 前端项目搭建</h4><ol>
<li><p>导入前端工程</p>
</li>
<li><p>安装npm依赖</p>
<p>进入前端工程项目文件夹下！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i</span><br></pre></td></tr></table></figure></li>
<li><p>启动前端程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-2-后端项目搭建"><a href="#2-2-后端项目搭建" class="headerlink" title="2.2 后端项目搭建"></a>2.2 后端项目搭建</h4><blockquote>
<p>数据库怎么办？使用HashMap模拟，所以不涉及和MyBatis、Spring的整合!</p>
</blockquote>
<ol>
<li><p>搭建后台项目</p>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- springioc相关依赖  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- web相关依赖  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在 pom.xml 中引入 Jakarta EE Web API 的依赖 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        在 Spring Web MVC 6 中，Servlet API 迁移到了 Jakarta EE API，因此在配置 DispatcherServlet 时需要使用</span></span><br><span class="line"><span class="comment">         Jakarta EE 提供的相应类库和命名空间。错误信息 “‘org.springframework.web.servlet.DispatcherServlet’</span></span><br><span class="line"><span class="comment">         is not assignable to ‘javax.servlet.Servlet,jakarta.servlet.Servlet’” 表明你使用了旧版本的</span></span><br><span class="line"><span class="comment">         Servlet API，没有更新到 Jakarta EE 规范。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- springwebmvc相关依赖  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>准备实体类</p>
<p>包：com.wzb.pojo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.wzb.pojo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * description: 任务实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Schedule</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boolean completed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Schedule</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Schedule</span><span class="params">(Integer id, String title, Boolean completed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.completed = completed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTitle</span><span class="params">(String title)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">getCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> completed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompleted</span><span class="params">(Boolean completed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.completed = completed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Schedule&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, title=&#x27;&quot;</span> + title + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, completed=&quot;</span> + completed +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>准备R结果包装类</p>
<p>包：com.wzb.utils</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.wzb.utils</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * description: 返回结果类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> <span class="number">200</span>; <span class="comment">//200成功状态码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//返回状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;  <span class="comment">//返回具体数据</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span>  <span class="keyword">static</span> R <span class="title function_">ok</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">        r.data = data;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R  <span class="title function_">fail</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">        r.code = <span class="number">500</span>; <span class="comment">//错误码</span></span><br><span class="line">        r.flag = <span class="literal">false</span>; <span class="comment">//错误状态</span></span><br><span class="line">        r.data = data;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备业务类</p>
<p>包：com.wzb.service</p>
<ol>
<li>业务接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.wzb.service</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * description: schedule业务接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ScheduleService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回全部学习计划</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Schedule&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存学习计划</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schedule</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveSchedule</span><span class="params">(Schedule schedule)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新学习计划</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schedule</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateSchedule</span><span class="params">(Schedule schedule)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除学习计划</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>业务实现<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.wzb.service.impl</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleServiceImpl</span>  <span class="keyword">implements</span> <span class="title class_">ScheduleService</span> &#123;</span><br><span class="line">    <span class="comment">//准备假数据</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,Schedule&gt; scheduleMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">maxId</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">            scheduleMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="type">Schedule</span> <span class="variable">schedule</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            schedule = <span class="keyword">new</span> <span class="title class_">Schedule</span>(<span class="number">1</span>, <span class="string">&quot;学习Java&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            scheduleMap.put(<span class="number">1</span>, schedule);</span><br><span class="line"></span><br><span class="line">            schedule = <span class="keyword">new</span> <span class="title class_">Schedule</span>(<span class="number">2</span>, <span class="string">&quot;学习H5&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            scheduleMap.put(<span class="number">2</span>, schedule);</span><br><span class="line"></span><br><span class="line">            schedule = <span class="keyword">new</span> <span class="title class_">Schedule</span>(<span class="number">3</span>, <span class="string">&quot;学习Css&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            scheduleMap.put(<span class="number">3</span>, schedule);</span><br><span class="line">            schedule = <span class="keyword">new</span> <span class="title class_">Schedule</span>(<span class="number">4</span>, <span class="string">&quot;学习JavaScript&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            scheduleMap.put(<span class="number">4</span>, schedule);</span><br><span class="line"></span><br><span class="line">            schedule = <span class="keyword">new</span> <span class="title class_">Schedule</span>(<span class="number">5</span>, <span class="string">&quot;学习Spring&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            scheduleMap.put(<span class="number">5</span>, schedule);</span><br><span class="line"></span><br><span class="line">        &#125;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回全部学习计划</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;Schedule&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(scheduleMap.values());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 保存学习计划</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> schedule</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveSchedule</span><span class="params">(Schedule schedule)</span> &#123;</span><br><span class="line">            maxId++;</span><br><span class="line">            schedule.setId(maxId);</span><br><span class="line">            scheduleMap.put(maxId,schedule);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 更新学习计划</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> schedule</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateSchedule</span><span class="params">(Schedule schedule)</span> &#123;</span><br><span class="line">            scheduleMap.put(schedule.getId(),schedule);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 移除学习计划</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">            scheduleMap.remove(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>准备spring-mvc.配置文件</p>
<p>位置：resources&#x2F;spring-mvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wzb.controller,com.wzb.service&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       注意: 导入mvc命名空间!</span></span><br><span class="line"><span class="comment">       mvc:annotation-driven 是一个整合标签</span></span><br><span class="line"><span class="comment">                             他会导入handlerMapping和handlerAdapter</span></span><br><span class="line"><span class="comment">                             他会导入json数据格式转化器等等!</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- viewResolver 不需要配置,因为我们不需要查找逻辑视图!!! --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加入这个配置，SpringMVC 就会在遇到没有 @RequestMapping 的请求时放它过去 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 所谓放它过去就是让这个请求去找它原本要访问的资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>准备 web.xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 配置SpringMVC中负责处理请求的核心Servlet，也被称为SpringMVC的前端控制器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- DispatcherServlet的全类名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 如果不记得contextConfigLocation配置项的名称，可以到DispatcherServlet的父类FrameworkServlet中查找 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 使用classpath:说明这个路径从类路径的根目录开始才查找 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 作为框架的核心组件，在启动过程中有大量的初始化操作要做，这些操作放在第一次请求时才执行非常不恰当 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们应该将DispatcherServlet设置为随Web应用一起启动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对DispatcherServlet来说，url-pattern有两种方式配置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方式一：配置“/”，表示匹配整个Web应用范围内所有请求。这里有一个硬性规定：不能写成“/*”。</span></span><br><span class="line"><span class="comment">      只有这一个地方有这个特殊要求，以后我们再配置Filter还是可以正常写“/*”。 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方式二：配置“*.扩展名”，表示匹配整个Web应用范围内部分请求 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-增删改查实现"><a href="#3-增删改查实现" class="headerlink" title="3. 增删改查实现"></a>3. 增删改查实现</h3><h4 id="4-1-项目根路径设计"><a href="#4-1-项目根路径设计" class="headerlink" title="4.1 项目根路径设计"></a>4.1 项目根路径设计</h4><p>因为前端项目设置了后台访问的项目根路径为 &#x2F;rest&#x20;</p>
<p>我们后台项目也对应的设置：</p>
<p>![](Spring MVC控制层框架&#x2F;image_fwsj8IhXZJ.png)</p>
<h4 id="4-2-SpringMVC解决跨域问题"><a href="#4-2-SpringMVC解决跨域问题" class="headerlink" title="4.2 SpringMVC解决跨域问题"></a>4.2 SpringMVC解决跨域问题</h4><p>假设我们有一个网站 <code>http://example.com</code>，现在需要跨域请求另外一个网站 <code>http://api.example.com</code> 中的数据。浏览器就会因为安全问题，拒绝客户端访问请求！</p>
<p>跨域问题是指在浏览器中发起跨域请求被浏览器拦截的问题。在同一个源域（同一协议、主机、端口），浏览器允许 JavaScript 发起跨域请求；在不同的源域下，浏览器对发起的异域请求会做出不同的限制。</p>
<p>常见的跨域问题的场景有：</p>
<ul>
<li>访问不同的子域名；</li>
<li>访问不同的端口号；</li>
<li>访问不同的协议（http、https）；</li>
<li>访问不同的域名；</li>
</ul>
<p>基于CORS方式，解决跨域思路：</p>
<p>CORS（Cross-Origin Resource Sharing）是 W3C 制定的一种跨域解决方案，它给出了跨域请求和响应的标准。服务器端代码需要在响应头中设置 Access-Control-Allow-Origin，并指定访问来源域名名或 * 通配符，表示允许的跨域请求。浏览器可以根据响应头信息，判断是否允许该请求。</p>
<p>SpringMVC基于CORS思路解决跨域方案：</p>
<ul>
<li><p>@CrossOrigin注解</p>
<p><code>@CrossOrigin</code> 注释在带注释的【控制器方法】 &#x2F; 【控制器类】上启用跨源请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CrossOrigin</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Account <span class="title function_">retrieve</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下， <code>@CrossOrigin</code> 允许：</p>
<ul>
<li>All origins.</li>
<li>All headers.</li>
<li>All HTTP methods to which the controller method is mapped. &#x20;<br>注解核心设置属性讲解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CrossOrigin &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置哪些客户端地址可以跨域访问! 格式为: 协议://主机地址:端口号</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@AliasFor(&quot;origins&quot;)</span></span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">  <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">  String[] origins() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置哪些客户端的[自定义请求头]可以跨域访问!</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String[] allowedHeaders() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置哪些服务端的自定义响应头,可以被客户端读取!</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String[] exposedHeaders() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *设置哪些请求方法,可以跨域方式! </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  RequestMethod[] methods() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 值为 true 或者 false</span></span><br><span class="line"><span class="comment">   * 客户端是否可以携带cookie!</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String <span class="title function_">allowCredentials</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>xml全局跨域配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:cors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">allowed-origins</span>=<span class="string">&quot;*&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">allowed-methods</span>=<span class="string">&quot;GET, PUT&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">allowed-headers</span>=<span class="string">&quot;header1, header2, header3&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">exposed-headers</span>=<span class="string">&quot;header1, header2&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">allow-credentials</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">allowed-origins</span>=<span class="string">&quot;https://domain1.com&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:cors</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-3-业务实现"><a href="#4-3-业务实现" class="headerlink" title="4.3 业务实现"></a>4.3 业务实现</h4><ol>
<li>查询业务<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.wzb.controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * description: 学习计划controller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    @CrossOrigin 注释在带注释的控制器方法上启用跨源请求</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    默认情况下， </span></span><br><span class="line"><span class="comment">    @CrossOrigin 允许：</span></span><br><span class="line"><span class="comment">            All origins  任何请求主机地址</span></span><br><span class="line"><span class="comment">            All headers  任何请求头</span></span><br><span class="line"><span class="comment">            All HTTP methods to which the controller method is mapped.  任何请求方式!</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">    可以设置:</span></span><br><span class="line"><span class="comment">         @CrossOrigin(origins = &quot;https://domain2.com&quot;) 指定允许跨域请求的主机地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;schedule&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleController</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ScheduleService scheduleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">showList</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Schedule&gt; list = scheduleService.getAll();</span><br><span class="line">        <span class="keyword">return</span>  R.ok(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li>
<li>修改业务<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">changeSchedule</span><span class="params">(<span class="meta">@RequestBody</span> Schedule schedule)</span>&#123;</span><br><span class="line">    scheduleService.updateSchedule(schedule);</span><br><span class="line">    <span class="keyword">return</span> R.ok(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>删除业务<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">removeSchedule</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">    scheduleService.removeById(id);</span><br><span class="line">    <span class="keyword">return</span> R.ok(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>保存业务<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">saveSchedule</span><span class="params">(<span class="meta">@RequestBody</span> Schedule schedule)</span>&#123;</span><br><span class="line">    scheduleService.saveSchedule(schedule);</span><br><span class="line">    <span class="keyword">return</span> R.ok(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="六、SpringMVC其他扩展"><a href="#六、SpringMVC其他扩展" class="headerlink" title="六、SpringMVC其他扩展"></a>六、SpringMVC其他扩展</h2><h3 id="1-异常处理机制"><a href="#1-异常处理机制" class="headerlink" title="1. 异常处理机制"></a>1. 异常处理机制</h3><h4 id="1-1-异常处理概念"><a href="#1-1-异常处理概念" class="headerlink" title="1.1 异常处理概念"></a>1.1 异常处理概念</h4><p>开发过程中是不可避免地会出现各种异常情况的，例如网络连接异常、数据格式异常、空指针异常等等。异常的出现可能导致程序的运行出现问题，甚至直接导致程序崩溃。因此，在开发过程中，合理处理异常、避免异常产生、以及对异常进行有效的调试是非常重要的。</p>
<p>对于异常的处理，一般分为两种方式：</p>
<ul>
<li>编程式异常处理：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用 try-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在 finally 块中执行一些清理操作。在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。</li>
<li>声明式异常处理：则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过配置等方式进行统一的管理和处理。在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如 <code>@Throws</code> 或 <code>@ExceptionHandler</code>），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。</li>
</ul>
<p>站在宏观角度来看待声明式事务处理：</p>
<p>整个项目从架构这个层面设计的异常处理的统一机制和规范。</p>
<p>一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照 A 方案处理异常，李四负责的模块按照 B 方案处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。</p>
<p>使用声明式异常处理，可以统一项目处理异常思路，项目更加清晰明了！</p>
<h4 id="1-2-声明式异常好处"><a href="#1-2-声明式异常好处" class="headerlink" title="1.2 声明式异常好处"></a>1.2 声明式异常好处</h4><p>![](Spring MVC控制层框架&#x2F;image_vIgpMpZh_2.png)</p>
<ul>
<li>使用声明式代替编程式来实现异常管理<ul>
<li>让异常控制和核心业务解耦，二者各自维护，结构性更好</li>
</ul>
</li>
<li>整个项目层面使用同一套规则来管理异常<ul>
<li>整个项目代码风格更加统一、简洁</li>
<li>便于团队成员之间的彼此协作</li>
</ul>
</li>
</ul>
<h4 id="1-3-基于注解异常声明异常处理"><a href="#1-3-基于注解异常声明异常处理" class="headerlink" title="1.3 基于注解异常声明异常处理"></a>1.3 基于注解异常声明异常处理</h4><ol>
<li><p>声明异常处理控制器类</p>
<p>异常处理控制类，统一定义异常处理handler方法！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.wzb.execptionhandler</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * description: 全局异常处理器,内部可以定义异常处理Handler!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RestControllerAdvice</span> = <span class="doctag">@ControllerAdvice</span> + <span class="doctag">@ResponseBody</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ControllerAdvice</span> 代表当前类的异常处理controller! </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>声明异常处理hander方法</p>
<p>异常处理handler方法和普通的handler方法参数接收和响应都一致！</p>
<p>只不过异常处理handler方法要映射异常，发生对应的异常会调用！</p>
<p>普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常处理handler </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ExceptionHandler</span>(HttpMessageNotReadableException.class) </span></span><br><span class="line"><span class="comment"> * 该注解标记异常处理Handler,并且指定发生异常调用该方法!</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 获取异常对象!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回handler处理结果!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(HttpMessageNotReadableException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerJsonDateException</span><span class="params">(HttpMessageNotReadableException e)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当发生空指针异常会触发此方法!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(NullPointerException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerNullException</span><span class="params">(NullPointerException e)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有异常都会触发此方法!但是如果有具体的异常处理Handler! </span></span><br><span class="line"><span class="comment"> * 具体异常处理Handler优先级更高!</span></span><br><span class="line"><span class="comment"> * 例如: 发生NullPointerException异常!</span></span><br><span class="line"><span class="comment"> *       会触发handlerNullException方法,不会触发handlerException方法!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerException</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件扫描控制器类配置</p>
<p>确保异常处理控制类被扫描</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wzb.controller,</span></span></span><br><span class="line"><span class="string"><span class="tag">   com.wzb.exceptionhandler&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>另外，如果响应的信息包含中文，则会出现中文乱码</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/plain;charset=utf-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html;charset=utf-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-拦截器使用"><a href="#2-拦截器使用" class="headerlink" title="2. 拦截器使用"></a>2. 拦截器使用</h3><h4 id="2-1-拦截器概念"><a href="#2-1-拦截器概念" class="headerlink" title="2.1 拦截器概念"></a>2.1 拦截器概念</h4><p>拦截器和过滤器解决问题</p>
<ul>
<li><p>生活中</p>
<p>为了提高乘车效率，在乘客进入站台前统一检票</p>
<p>![](Spring MVC控制层框架&#x2F;img008_Cu_s178zpF.png)</p>
</li>
<li><p>程序中</p>
<p>在程序中，使用拦截器在请求到达具体 handler 方法前，统一执行检测</p>
<p>![](Spring MVC控制层框架&#x2F;img009_ZoPtaL048I.png)</p>
</li>
</ul>
<p>拦截器 VS 过滤器：</p>
<ul>
<li>相似点<ul>
<li>拦截：必须先把请求拦住，才能执行后续操作</li>
<li>过滤：拦截器或过滤器存在的意义就是对请求进行统一处理</li>
<li>放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源</li>
</ul>
</li>
<li>不同点<ul>
<li>工作平台不同<ul>
<li>过滤器工作在 Servlet 容器中</li>
<li>拦截器工作在 SpringMVC 的基础上</li>
</ul>
</li>
<li>拦截的范围<ul>
<li>过滤器：能够拦截到的最大范围是整个 Web 应用</li>
<li>拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求</li>
</ul>
</li>
<li>IOC 容器支持<ul>
<li>过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的</li>
<li>拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>选择：</p>
<p>功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器。</p>
<p>![](Spring MVC控制层框架&#x2F;image_h_FVVk92VB.png)</p>
<h4 id="2-2-拦截器使用"><a href="#2-2-拦截器使用" class="headerlink" title="2.2 拦截器使用"></a>2.2 拦截器使用</h4><ol>
<li><p>创建拦截器类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Process01Interceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在处理请求的目标 handler 方法前执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler);</span><br><span class="line">        System.out.println(<span class="string">&quot;Process01Interceptor.preHandle&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 返回true：放行</span></span><br><span class="line">        <span class="comment">// 返回false：不放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在目标 handler 方法之后，handler报错不执行!</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, modelAndView = &quot;</span> + modelAndView);</span><br><span class="line">        System.out.println(<span class="string">&quot;Process01Interceptor.postHandle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 渲染视图之后执行(最后),一定执行!</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, ex = &quot;</span> + ex);</span><br><span class="line">        System.out.println(<span class="string">&quot;Process01Interceptor.afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单个拦截器执行顺序:</p>
<ul>
<li>preHandle() 方法</li>
<li>目标 handler 方法</li>
<li>postHandle() 方法</li>
<li>渲染视图(返回json没有此步骤)</li>
<li>afterCompletion() 方法</li>
</ul>
</li>
<li><p>拦截器配置</p>
<p>springmvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 默认拦截器,拦截所有请求--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.wzb.interceptor.Process01Interceptor&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>配置详解</p>
<ol>
<li>默认拦截全部<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 拦截全部的请求地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.wzb.mvc.interceptor.Process03Interceptor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>精准配置<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 具体配置拦截器可以指定拦截的请求地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 精确匹配 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/common/request/one&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.wzb.mvc.interceptor.Process03Interceptor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- /*匹配路径中的一层 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/common/request/*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.wzb.mvc.interceptor.Process04Interceptor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- /**匹配路径中的多层 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/common/request/**&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.wzb.mvc.interceptor.Process05Interceptor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>排除配置<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- /**匹配路径中的多层 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/common/request/**&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用 mvc:exclude-mapping 标签配置不拦截的地址 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/common/request/two/bbb&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.wzb.mvc.interceptor.Process05Interceptor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
</li>
<li><p>多个拦截器执行顺序</p>
<ol>
<li>preHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置顺序调用各个 preHandle() 方法。</li>
<li>postHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 postHandle() 方法。</li>
<li>afterCompletion() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 afterCompletion() 方法。</li>
</ol>
</li>
</ol>
<h4 id="2-3-拦截器作用位置图解"><a href="#2-3-拦截器作用位置图解" class="headerlink" title="2.3 拦截器作用位置图解"></a>2.3 拦截器作用位置图解</h4><p>![](Spring MVC控制层框架&#x2F;image_ykneI-kQzc.png)</p>
<h4 id="2-4-拦截器案例"><a href="#2-4-拦截器案例" class="headerlink" title="2.4 拦截器案例"></a>2.4 拦截器案例</h4><p>一个网站有 56个资源，其中一个为登陆资源，两个无须登录即可访问，另外三个需要登录后才能访问。如果不登录就访问那三个资源，需要拦截，并且提示登录后访问访问！</p>
<p>提示：登陆为模拟登陆，存储一个user可以到session即可！</p>
<p>访问资源的请求地址可参考：</p>
<ul>
<li>登陆资源：&#x2F;public&#x2F;resource&#x2F;login</li>
<li>公共资源1：&#x2F;public&#x2F;resource&#x2F;one</li>
<li>公共资源2：&#x2F;public&#x2F;resouce&#x2F;two</li>
<li>私密资源1：&#x2F;private&#x2F;resouce&#x2F;one</li>
<li>私密资源2：&#x2F;private&#x2F;resouce&#x2F;two</li>
<li>私密资源3：&#x2F;private&#x2F;resouce&#x2F;three</li>
</ul>
<p>案例实现：</p>
<ol>
<li>声明资源类<ol>
<li>PublicController<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.wzb.controller</span></span><br><span class="line"><span class="comment"> * description: 公有资源控制类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;public/resource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublicController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟登录,将假用户数据存储到session中!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">login</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;one&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">one</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;public one&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;two&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">two</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;public two&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>PrivateController<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;private/resource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;one&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">one</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;private one&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;two&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">two</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;private two&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;three&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">three</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;private two&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>声明拦截器类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.wzb.interceptor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * description: 登录保护拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginProtectInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录保护方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response current HTTP response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler chosen handler to execute, for type and/or instance evaluation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>)&#123;</span><br><span class="line">            response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//没有登录</span></span><br><span class="line">            response.getWriter().print(<span class="string">&quot;请先登录,再访问! &lt;a href=&#x27;/public/resource/login&#x27;&gt;点击此处登录&lt;/a&gt;&quot;</span>);</span><br><span class="line">            <span class="comment">//拦截,不到达目标地址</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置拦截器类<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/private/**&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.wzb.interceptor.LoginProtectInterceptor&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-参数校验"><a href="#3-参数校验" class="headerlink" title="3. 参数校验"></a>3. 参数校验</h3><blockquote>
<p>在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。</p>
</blockquote>
<ol>
<li><p><strong>校验概述</strong></p>
<p>JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td>@Null</td>
<td>标注值必须为 null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>标注值不可为 null</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>标注值必须为 true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>标注值必须为 false</td>
</tr>
<tr>
<td>@Min(value)</td>
<td>标注值必须大于或等于 value</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>标注值必须小于或等于 value</td>
</tr>
<tr>
<td>@DecimalMin(value)</td>
<td>标注值必须大于或等于 value</td>
</tr>
<tr>
<td>@DecimalMax(value)</td>
<td>标注值必须小于或等于 value</td>
</tr>
<tr>
<td>@Size(max,min)</td>
<td>标注值大小必须在 max 和 min 限定的范围内</td>
</tr>
<tr>
<td>@Digits(integer,fratction)</td>
<td>标注值值必须是一个数字，且必须在可接受的范围内</td>
</tr>
<tr>
<td>@Past</td>
<td>标注值只能用于日期型，且必须是过去的日期</td>
</tr>
<tr>
<td>@Future</td>
<td>标注值只能用于日期型，且必须是将来的日期</td>
</tr>
<tr>
<td>@Pattern(value)</td>
<td>标注值必须符合指定的正则表达式</td>
</tr>
<tr>
<td>JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解：</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>注解</th>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td>@Email</td>
<td>标注值必须是格式正确的 Email 地址</td>
</tr>
<tr>
<td>@Length</td>
<td>标注值字符串大小必须在指定的范围内</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>标注值字符串不能是空字符串</td>
</tr>
<tr>
<td>@Range</td>
<td>标注值必须在指定的范围内</td>
</tr>
</tbody></table>
<p>Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 mvc:annotation-driven 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。</p>
<p>配置 <strong>mvc:annotation-driven</strong> 后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。</p>
</li>
<li><p><strong>操作演示</strong></p>
<ul>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 校验注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!-- 校验注解实现--&gt;</span>        </span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator-annotation-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>应用校验注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.Email;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.wzb.pojo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">//age   1 &lt;=  age &lt; = 150</span></span><br><span class="line">    <span class="meta">@Min(10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//name 3 &lt;= name.length &lt;= 6</span></span><br><span class="line">    <span class="meta">@Length(min = 3,max = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//email 邮箱格式</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>handler标记和绑定错误收集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Validated</span> 代表应用校验注解! 必须添加!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">save</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> User user,</span></span><br><span class="line"><span class="params">                       //在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出!</span></span><br><span class="line"><span class="params">                       BindingResult result)</span>&#123;</span><br><span class="line">       <span class="comment">//判断是否有信息绑定错误! 有可以自行处理!</span></span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;错误&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> result.getFieldError().toString();</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有,正常处理业务即可</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试效果</p>
<p>![](Spring MVC控制层框架&#x2F;image_ciuI5tAmH6.png)</p>
</li>
</ul>
</li>
<li><p><strong>易混总结</strong></p>
<p>@NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。</p>
<ol>
<li><p>@NotNull  (包装类型不为null)</p>
<p>@NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。</p>
</li>
<li><p>@NotEmpty (集合类型长度大于0)</p>
<p>@NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map 或者数组对象类型的属性进行校验，校验时会检查该属性是否为 Null 或者 size()&#x3D;&#x3D;0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。</p>
</li>
<li><p>@NotBlank （字符串，不为null，切不为”  “字符串）</p>
<p>@NotBlank 注解是 Hibernate Validator 附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 Null 或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank 注解只能用于字符串类型的校验。<br>总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。</p>
</li>
</ol>
</li>
</ol>
<h3 id="4-文件上传和下载-x20"><a href="#4-文件上传和下载-x20" class="headerlink" title="4.文件上传和下载&#x20;"></a>4.文件上传和下载&#x20;</h3><h4 id="4-1-文件上传"><a href="#4-1-文件上传" class="headerlink" title="4.1 文件上传"></a>4.1 文件上传</h4><ol>
<li><p><strong>文件上传表单页面</strong></p>
<p>位置：index.html</p>
<ul>
<li>第一点：请求方式必须是 POST</li>
<li>第二点：请求体的编码方式必须是 multipart&#x2F;form-data（通过 form 标签的 enctype 属性设置）</li>
<li>第三点：使用 input 标签、type 属性设置为 file 来生成文件上传框</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/save/picture&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">      昵称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;nickName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;龙猫&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      头像：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;headPicture&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      背景：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;backgroundPicture&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>保存<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>springmvc环境要求</strong></p>
<p>pom.xml添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置文件上传处理器(springmvc配置)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件上传处理器,可处理 multipart/* 请求并将其转换为 MultipartFile 对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>CommonsMultipartResolver的bean的id，必须是：multipartResolver<br>如果不是这个值，会在上传文件时报错<br>在 <code>web.xml</code> 文件中添加 Multipart 配置</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>yourAppServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">multipart-config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义文件上传时所需的最大值，单位为字节 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">max-file-size</span>&gt;</span>10485760<span class="tag">&lt;/<span class="name">max-file-size</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义单个上传文件的最大值，单位为字节 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">max-request-size</span>&gt;</span>20971520<span class="tag">&lt;/<span class="name">max-request-size</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义内存中存储文件的最大值，超过此大小的文件会写入到硬盘中 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file-size-threshold</span>&gt;</span>5242880<span class="tag">&lt;/<span class="name">file-size-threshold</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">multipart-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>低版本web.xml约束文件，会爆红，不管担心，继续启动即可！</p>
<blockquote>
<p>历史：Spring MVC 6之前，通常使用的是 <code>CommonsMultipartResolver</code> 来解析文件上传请求。但是在 Spring MVC 6中，此类已被移除，Spring 官方推荐使用 <code>StandardServletMultipartResolver</code> 或 <code>MockMultipartResolver</code> 来替代。</p>
</blockquote>
</li>
<li><p><strong>handler方法接收数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传的文件使用 MultipartFile 类型接收其相关数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nickName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> picture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> backgroundPicture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping</span> (<span class="string">&quot;picture&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(String nickName, <span class="meta">@RequestPart(&quot;headPicture&quot;)</span> MultipartFile picture, <span class="meta">@RequestPart(&quot;backgroundPicture&quot;)</span>MultipartFile backgroundPicture)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(nickName);</span><br><span class="line">     <span class="type">String</span> <span class="variable">inputName</span> <span class="operator">=</span> picture.getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;文件上传表单项的 name 属性值：&quot;</span> + inputName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取这个数据通常都是为了获取文件本身的扩展名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> picture.getOriginalFilename();</span><br><span class="line">    System.out.println(<span class="string">&quot;文件在用户本地原始的文件名：&quot;</span> + originalFilename);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> picture.getContentType();</span><br><span class="line">    System.out.println(<span class="string">&quot;文件的内容类型：&quot;</span> + contentType);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">empty</span> <span class="operator">=</span> picture.isEmpty();</span><br><span class="line">    System.out.println(<span class="string">&quot;文件是否为空：&quot;</span> + empty);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> picture.getSize();</span><br><span class="line">    System.out.println(<span class="string">&quot;文件大小：&quot;</span> + size);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] bytes = picture.getBytes();</span><br><span class="line">    System.out.println(<span class="string">&quot;文件二进制数据的字节数组：&quot;</span> + Arrays.asList(bytes));</span><br><span class="line"></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> picture.getInputStream();</span><br><span class="line">    System.out.println(<span class="string">&quot;读取文件数据的输入流对象：&quot;</span> + inputStream);</span><br><span class="line"></span><br><span class="line">    <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> picture.getResource();</span><br><span class="line">    System.out.println(<span class="string">&quot;代表当前 MultiPartFile 对象的资源对象&quot;</span> + resource);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>MultipartFile接口</strong></p>
<p>![](Spring MVC控制层框架&#x2F;img014_ciD7FfevEJ.png)</p>
</li>
<li><p><strong>文件转存</strong></p>
<ol>
<li><p>底层机制</p>
<p>![](Spring MVC控制层框架&#x2F;img015_U98i7AFmF-.png)</p>
</li>
<li><p>本地转存</p>
<p>![](Spring MVC控制层框架&#x2F;img016_NDUl5QE_QR.png)</p>
<p>转存代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1、准备好保存文件的目标目录</span></span><br><span class="line"><span class="comment">// ①File 对象要求目标路径是一个物理路径（在硬盘空间里能够直接找到文件的路径）</span></span><br><span class="line"><span class="comment">// ②项目在不同系统平台上运行，要求能够自动兼容、适配不同系统平台的路径格式</span></span><br><span class="line"><span class="comment">//      例如：Window系统平台的路径是 D:/aaa/bbb 格式</span></span><br><span class="line"><span class="comment">//      例如：Linux系统平台的路径是 /ttt/uuu/vvv 格式</span></span><br><span class="line"><span class="comment">//      所以我们需要根据『不会变的虚拟路径』作为基准动态获取『跨平台的物理路径』</span></span><br><span class="line"><span class="comment">// ③虚拟路径：浏览器通过 Tomcat 服务器访问 Web 应用中的资源时使用的路径</span></span><br><span class="line"><span class="type">String</span> <span class="variable">destFileFolderVirtualPath</span> <span class="operator">=</span> <span class="string">&quot;/head-picture&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ④调用 ServletContext 对象的方法将虚拟路径转换为真实物理路径</span></span><br><span class="line"><span class="type">String</span> <span class="variable">destFileFolderRealPath</span> <span class="operator">=</span> servletContext.getRealPath(destFileFolderVirtualPath);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2、生成保存文件的文件名</span></span><br><span class="line"><span class="comment">// ①为了避免同名的文件覆盖已有文件，不使用 originalFilename，所以需要我们生成文件名</span></span><br><span class="line"><span class="comment">// ②我们生成文件名包含两部分：文件名本身和扩展名</span></span><br><span class="line"><span class="comment">// ③声明变量生成文件名本身</span></span><br><span class="line"><span class="type">String</span> <span class="variable">generatedFileName</span> <span class="operator">=</span> UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ④根据 originalFilename 获取文件的扩展名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">fileExtname</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ⑤拼装起来就是我们生成的整体文件名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">destFileName</span> <span class="operator">=</span> generatedFileName + <span class="string">&quot;&quot;</span> + fileExtname;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3、拼接保存文件的路径，由两部分组成</span></span><br><span class="line"><span class="comment">//      第一部分：文件所在目录</span></span><br><span class="line"><span class="comment">//      第二部分：文件名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> destFileFolderRealPath + <span class="string">&quot;/&quot;</span> + destFileName;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4、创建 File 对象，对应文件具体保存的位置</span></span><br><span class="line"><span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destFilePath);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 5、执行转存</span></span><br><span class="line">picture.transferTo(destFile);</span><br><span class="line"> </span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>缺陷</p>
<ul>
<li>Web 应用重新部署时通常都会清理旧的构建结果，此时用户以前上传的文件会被删除，导致数据丢失。</li>
<li>项目运行很长时间后，会导致上传的文件积累非常多，体积非常大，从而拖慢 Tomcat 运行速度。</li>
<li>当服务器以集群模式运行时，文件上传到集群中的某一个实例，其他实例中没有这个文件，就会造成数据不一致。</li>
<li>不支持动态扩容，一旦系统增加了新的硬盘或新的服务器实例，那么上传、下载时使用的路径都需要跟着变化，导致 Java 代码需要重新编写、重新编译，进而导致整个项目重新部署。<br>![](Spring MVC控制层框架&#x2F;img018_Fd9zEfZjJZ.png)</li>
</ul>
</li>
<li><p>文件服务器转存（推荐）</p>
<p>![](Spring MVC控制层框架&#x2F;img019_0pV4kR24fK.png)</p>
<p>好处</p>
<ul>
<li>不受 Web 应用重新部署影响</li>
<li>在应用服务器集群环境下不会导致数据不一致</li>
<li>针对文件读写进行专门的优化，性能有保障</li>
<li>能够实现动态扩容<br>![](Spring MVC控制层框架&#x2F;img020_TUZbWX5oA6.png)<br><strong>文件服务器类型</strong></li>
<li>第三方平台：<ul>
<li>阿里的 OSS 对象存储服务</li>
<li>七牛云</li>
</ul>
</li>
<li>自己搭建服务器：FastDFS 等</li>
</ul>
</li>
<li><p>上传到其他模块</p>
<p>这种情况肯定出现在分布式架构中，常规业务功能不会这么做，采用这个方案的一定是特殊情况，这种情况极其少见。</p>
<p>![](Spring MVC控制层框架&#x2F;img021_GYdAmeWInU.png)</p>
<p>在 MultipartFile 接口中有一个对应的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a Resource representation of this MultipartFile. This can be used</span></span><br><span class="line"><span class="comment"> * as input to the &#123;<span class="doctag">@code</span> RestTemplate&#125; or the &#123;<span class="doctag">@code</span> WebClient&#125; to expose</span></span><br><span class="line"><span class="comment"> * content length and the filename along with the InputStream.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> this MultipartFile adapted to the Resource contract</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> Resource <span class="title function_">getResource</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MultipartFileResource</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释中说：这个 Resource 对象代表当前 MultipartFile 对象，输入给 RestTemplate 或 WebClient。而 RestTemplate 或 WebClient 就是用来在 Java 程序中向服务器端发出请求的组件。</p>
</li>
</ol>
</li>
</ol>
<h4 id="4-2-文件下载"><a href="#4-2-文件下载" class="headerlink" title="4.2 文件下载"></a>4.2 文件下载</h4><p>在 Spring MVC 中，<code>ResponseEntity</code> 是用于表示 HTTP 响应的一个类，它既能设置响应体的内容，也能设置响应头相关的信息。</p>
<p><code>ResponseEntity</code> 可以封装一个 HTTP 响应，包括响应体、响应头和响应状态码等属性，并将其发送回客户端。它提供了一种灵活的方式来表示 HTTP 响应，可以用于处理 RESTful API、文件下载、异常处理等应用场景。</p>
<p>演示json数据返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;age&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable(&quot;age&quot;)</span> <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(age);</span><br><span class="line">    user.setEmail(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;二狗子&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示文件下载代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/download/file&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; downloadFile() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.获取要下载的文件的输入流对象</span></span><br><span class="line">    <span class="comment">// 这里指定的路径以 Web 应用根目录为基准</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> servletContext.getResourceAsStream(<span class="string">&quot;/images/mi.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.将要下载的文件读取到字节数组中</span></span><br><span class="line">        <span class="comment">// ①获取目标文件的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.available();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ②根据目标文件长度创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③将目标文件读取到字节数组中</span></span><br><span class="line">        inputStream.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.封装响应消息头</span></span><br><span class="line">        <span class="comment">// ①创建MultiValueMap接口类型的对象，实现类是HttpHeaders</span></span><br><span class="line">        <span class="type">MultiValueMap</span> <span class="variable">responseHeaderMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ②存入下载文件所需要的响应消息头</span></span><br><span class="line">        responseHeaderMap.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=mi.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③创建ResponseEntity对象</span></span><br><span class="line">        ResponseEntity&lt;<span class="type">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(buffer, responseHeaderMap, HttpStatus.OK);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.返回responseEntity对象</span></span><br><span class="line">        <span class="keyword">return</span> responseEntity;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、SpringMVC底层原理"><a href="#七、SpringMVC底层原理" class="headerlink" title="七、SpringMVC底层原理"></a>七、SpringMVC底层原理</h2><h3 id="1-启动配置流程"><a href="#1-启动配置流程" class="headerlink" title="1. 启动配置流程"></a>1. 启动配置流程</h3><h4 id="1-1-Servlet-生命周期回顾"><a href="#1-1-Servlet-生命周期回顾" class="headerlink" title="1.1 Servlet 生命周期回顾"></a>1.1 Servlet 生命周期回顾</h4><p>![](Spring MVC控制层框架&#x2F;img002_4CPXs6G8ar.png)</p>
<table>
<thead>
<tr>
<th>生命周期环节</th>
<th>调用的方法</th>
<th>时机</th>
<th>次数</th>
</tr>
</thead>
<tbody><tr>
<td>创建对象</td>
<td>无参构造器</td>
<td>默认：第一次请求&#xA;修改：Web应用启动时</td>
<td>一次</td>
</tr>
<tr>
<td>初始化</td>
<td>init(ServletConfig servletConfig)</td>
<td>创建对象后</td>
<td>一次</td>
</tr>
<tr>
<td>处理请求</td>
<td>service(ServletRequest servletRequest, ServletResponse servletResponse)</td>
<td>接收到请求后</td>
<td>多次</td>
</tr>
<tr>
<td>清理操作</td>
<td>destroy()</td>
<td>Web应用卸载之前</td>
<td>一次</td>
</tr>
</tbody></table>
<h4 id="1-2-初始化操作调用路线图"><a href="#1-2-初始化操作调用路线图" class="headerlink" title="1.2 初始化操作调用路线图"></a>1.2 初始化操作调用路线图</h4><p>类和接口之间的关系:</p>
<p>![](Spring MVC控制层框架&#x2F;img116_feXAAVNpoZ.png)</p>
<p>调用线路图:</p>
<p>调用线路图所示是方法调用的顺序，但是实际运行的时候本质上都是调用 DispatcherServlet 对象的方法。包括这里涉及到的接口的方法，也不是去调用接口中的『抽象方法』。毕竟抽象方法是没法执行的。抽象方法一定是在某个实现类中有具体实现才能被调用。</p>
<p>而对于最终的实现类：DispatcherServlet 来说，所有父类的方法最后也都是在 DispatcherServlet 对象中被调用的。</p>
<p>![](Spring MVC控制层框架&#x2F;img005_WfQZAJl_k4.png)</p>
<h4 id="1-3-SpringMVC-IoC-容器创建"><a href="#1-3-SpringMVC-IoC-容器创建" class="headerlink" title="1.3 SpringMVC IoC 容器创建"></a>1.3 SpringMVC IoC 容器创建</h4><p>所在类：org.springframework.web.servlet.FrameworkServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> &#123;</span><br><span class="line">  Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">  <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(</span><br><span class="line">        <span class="string">&quot;Fatal initialization error in servlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">        <span class="string">&quot;&#x27;: custom WebApplicationContext class [&quot;</span> + contextClass.getName() +</span><br><span class="line">        <span class="string">&quot;] is not of type ConfigurableWebApplicationContext&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过反射创建 IOC 容器对象</span></span><br><span class="line">  <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span></span><br><span class="line">      (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"></span><br><span class="line">  wac.setEnvironment(getEnvironment());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置父容器</span></span><br><span class="line">  wac.setParent(parent);</span><br><span class="line">  <span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> getContextConfigLocation();</span><br><span class="line">  <span class="keyword">if</span> (configLocation != <span class="literal">null</span>) &#123;</span><br><span class="line">    wac.setConfigLocation(configLocation);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 配置并且刷新：在这个过程中就会去读XML配置文件并根据配置文件创建bean、加载各种组件</span></span><br><span class="line">  configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-将-SpringMVC-IoC容器对象存入应用域"><a href="#1-4-将-SpringMVC-IoC容器对象存入应用域" class="headerlink" title="1.4 将 SpringMVC IoC容器对象存入应用域"></a>1.4 将 SpringMVC IoC容器对象存入应用域</h4><p>所在类：org.springframework.web.servlet.FrameworkServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">WebApplicationContext</span> <span class="variable">rootContext</span> <span class="operator">=</span></span><br><span class="line">      WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">  <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.webApplicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">    wac = <span class="built_in">this</span>.webApplicationContext;</span><br><span class="line">    <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">      <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">cwac</span> <span class="operator">=</span> (ConfigurableWebApplicationContext) wac;</span><br><span class="line">      <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//springmvc容器认另一个容器（spring）作为父容器</span></span><br><span class="line">          cwac.setParent(rootContext);</span><br><span class="line">        &#125;</span><br><span class="line">        configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">    wac = findWebApplicationContext();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建 IOC 容器</span></span><br><span class="line">    wac = createWebApplicationContext(rootContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.refreshEventReceived) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">      onRefresh(wac);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.publishContext) &#123;</span><br><span class="line">    <span class="comment">// 获取存入应用域时专用的属性名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> getServletContextAttributeName();</span><br><span class="line">        <span class="comment">// 存入</span></span><br><span class="line">    getServletContext().setAttribute(attrName, wac);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这一点的意义：SpringMVC 有一个工具方法，可以从应用域获取 IOC 容器对象的引用。</p>
<p>工具类：org.springframework.web.context.support.<strong>WebApplicationContextUtils</strong></p>
<p>工具方法：<strong>getWebApplicationContext</strong>()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WebApplicationContext <span class="title function_">getWebApplicationContext</span><span class="params">(ServletContext sc)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：将来假如我们自己开发时，在IOC容器之外需要从IOC容器中获取bean，那么就可以通过这个工具方法获取IOC容器对象的引用。IOC容器之外的场景会有很多，比如在一个我们自己创建的Filter中。</p>
<h4 id="1-5-请求映射初始化"><a href="#1-5-请求映射初始化" class="headerlink" title="1.5 请求映射初始化"></a>1.5 请求映射初始化</h4><p>FrameworkServlet.createWebApplicationContext()→configureAndRefreshWebApplicationContext()→wac.refresh()→触发刷新事件→org.springframework.web.servlet.DispatcherServlet.initStrategies()→org.springframework.web.servlet.DispatcherServlet.initHandlerMappings()</p>
<p>![](Spring MVC控制层框架&#x2F;img006_vnMiRnTzrm.png)</p>
<h4 id="1-6-小结"><a href="#1-6-小结" class="headerlink" title="1.6 小结"></a>1.6 小结</h4><p>整个启动过程我们关心如下要点：</p>
<ul>
<li>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。</li>
<li>DispatcherServlet 的父类是 FrameworkServlet。<ul>
<li>FrameworkServlet 负责框架本身相关的创建和初始化。</li>
<li>DispatcherServlet 负责请求处理相关的初始化。</li>
</ul>
</li>
<li>FrameworkServlet 创建 IOC 容器对象之后会存入应用域。</li>
<li>FrameworkServlet 完成初始化会调用 IOC 容器的刷新方法。</li>
<li>刷新方法完成触发刷新事件，在刷新事件的响应函数中，调用 DispatcherServlet 的初始化方法。</li>
<li>在 DispatcherServlet 的初始化方法中初始化了请求映射等。</li>
</ul>
<h3 id="2-请求处理流程原理"><a href="#2-请求处理流程原理" class="headerlink" title="2. 请求处理流程原理"></a>2. 请求处理流程原理</h3><h4 id="2-1-总体阶段"><a href="#2-1-总体阶段" class="headerlink" title="2.1 总体阶段"></a>2.1 总体阶段</h4><ol>
<li><p>流程描述</p>
<ul>
<li>目标 handler 方法执行<strong>前</strong><ul>
<li>建立调用链，确定整个执行流程</li>
<li>拦截器的 preHandle() 方法</li>
<li>注入请求参数</li>
<li>准备目标 handler 方法所需所有参数</li>
</ul>
</li>
<li><strong>调用</strong>目标 handler 方法</li>
<li>目标 handler 方法执行<strong>后</strong><ul>
<li>拦截器的 postHandle() 方法</li>
<li>渲染视图</li>
<li>拦截器的 afterCompletion() 方法</li>
</ul>
</li>
</ul>
</li>
<li><p>核心代码</p>
<p>整个请求处理过程都是doDispatch()方法在宏观上协调和调度，把握了这个方法就理解了 SpringMVC 总体上是如何处理请求的。</p>
<p>所在类：<strong>DispatcherServlet</strong></p>
<p>所在方法：doDispatch()</p>
<p>核心方法中的核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-2-调用前阶段"><a href="#2-2-调用前阶段" class="headerlink" title="2.2 调用前阶段"></a>2.2 调用前阶段</h4><ol>
<li><p>建立调用链</p>
<p>全类名：org.springframework.web.servlet.HandlerExecutionChain</p>
<p>![](Spring MVC控制层框架&#x2F;img003_2YuoobIwMF.png)</p>
<p>拦截器索引默认是 -1，说明开始的时候，它指向第一个拦截器前面的位置。每执行一个拦截器，就把索引向前移动一个位置。所以这个索引每次都是指向当前拦截器。所以它相当于拦截器的<strong>指针</strong>。</p>
</li>
<li><p>对应操作</p>
<p>所在类：org.springframework.web.servlet.handler.AbstractHandlerMapping</p>
<p>所在方法：getHandlerExecutionChain()</p>
<p>关键操作：</p>
<ul>
<li><p>把目标handler对象存入</p>
</li>
<li><p>把当前请求要经过的拦截器存入</p>
<p>![](Spring MVC控制层框架&#x2F;img004_ydSfnkOq6R.png)</p>
<p>结论：调用链是由拦截器和目标 handler 对象组成的。</p>
</li>
</ul>
</li>
<li><p>调用拦截器preHandle()</p>
<p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<p>所在方法：doDispatch()</p>
<p>![](Spring MVC控制层框架&#x2F;img007_A_9AZHyoTN.png)</p>
<p>具体调用细节：正序调用</p>
<p>所在类：org.springframework.web.servlet.HandlerExecutionChain</p>
<p>所在方法：applyPreHandle</p>
<p>![](Spring MVC控制层框架&#x2F;img008_htFE6CSadg.png)</p>
<p>从这部分代码我们也能看到，为什么拦截器中的 preHandle() 方法通过返回布尔值能够控制是否放行。</p>
<ul>
<li>每一个拦截器的 preHandle() 方法都返回 true：applyPreHandle() 方法返回 true，被取反就不执行 if 分支，继续执行后续操作，这就是放行。</li>
<li>任何一个拦截器的 preHandle() 方法返回 false：applyPreHandle() 方法返回 false，被取反执行 if 分支，return，导致 doDispatch() 方法结束，不执行后续操作，就是不放行。</li>
</ul>
</li>
<li><p>注入请求参数</p>
<p>相关组件：</p>
<p>接口：org.springframework.web.servlet.HandlerAdapter</p>
<p>作用：字面含义是适配器的意思，具体功能有三个</p>
<ul>
<li>将请求参数绑定到实体类对象中</li>
<li>给目标 handler 方法准备所需的其他参数，例如：<ul>
<li>Model、ModelMap、Map……</li>
<li>原生 Servlet API：request、response、session……</li>
<li>BindingResult</li>
<li>@RequestParam 注解标记的零散请求参数</li>
<li>@PathVariable 注解标记的路径变量</li>
</ul>
</li>
<li>调用目标 handler 方法<br>所以 HandlerAdapter 这个适配器是将底层的 HTTP 报文、原生的 request 对象进行解析和封装，『适配』到我们定义的 handler 方法上。<br>创建并获取这个组件</li>
</ul>
<p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<p>所在方法：doDispatch()</p>
<p>![](Spring MVC控制层框架&#x2F;img009_LAQfA_01-A.png)</p>
<p>具体操作：调用目标 handler 方法</p>
<p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<p>所在方法：doDispatch()</p>
<p>![](Spring MVC控制层框架&#x2F;img010_O3sCPwLR6_.png)</p>
<p>具体操作：注入请求参数</p>
<p>![](Spring MVC控制层框架&#x2F;img011_nwOb9QEP_8.png)</p>
<p>通过反射给对应属性注入请求参数应该是下面的过程：</p>
<ul>
<li>获取请求参数名称</li>
<li>将请求参数名称首字母设定为大写</li>
<li>在首字母大写后的名称前附加 set，得到目标方法名</li>
<li>通过反射调用 setXxx() 方法</li>
</ul>
</li>
</ol>
<h4 id="2-3调用后阶段"><a href="#2-3调用后阶段" class="headerlink" title="2.3调用后阶段"></a>2.3调用后阶段</h4><ol>
<li><p>调用拦截器的 postHandle() 方法</p>
<p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<p>所在方法：doDispatch()</p>
<p>![](Spring MVC控制层框架&#x2F;img014_wAV36G4Yvi.png)</p>
<p>调用细节：从拦截器集合长度 - 1 开始循环，循环到 0 为止。所以是<strong>倒序</strong>执行，从而让各个拦截器形成<strong>嵌套执行</strong>的效果，和AOP有异曲同工之妙。</p>
<p>![](Spring MVC控制层框架&#x2F;img015_YPEZAdac0w.png)</p>
</li>
<li><p>渲染视图</p>
<p>所有后续操作的入口:</p>
<p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<p>所在方法：doDispatch()</p>
<p>![](Spring MVC控制层框架&#x2F;img016_Ma3QoHPrlV.png)</p>
<p>后续细节1：处理异常:</p>
<p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<p>所在方法：processDispatchResult()</p>
<p>![](Spring MVC控制层框架&#x2F;img017_0mgDXuRD9X.png)</p>
<p>后续细节2：渲染视图:</p>
<p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<p>所在方法：processDispatchResult()</p>
<p>![](Spring MVC控制层框架&#x2F;img018_QKs8RvbiNR.png)</p>
<p>补充细节：模型数据存入请求域的具体位置</p>
<p>所在类：org.thymeleaf.context.WebEngineContext.RequestAttributesVariablesMap</p>
<p>所在方法：setVariable()</p>
<p>![](Spring MVC控制层框架&#x2F;img020_6YXuHbo-6o.png)</p>
</li>
<li><p>调用拦截器的 afterCompletion() 方法</p>
<p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<p>所在方法：processDispatchResult()</p>
<p>![](Spring MVC控制层框架&#x2F;img019_jnu2SgB4zG.png)</p>
<p>调用细节：从拦截器索引开始循环，直到循环变量 i 被减到 0 为止。这样的效果是前面执行拦截器到哪里，就从哪里倒回去执行；前面没有执行的拦截器，现在也不执行。</p>
<p>![](Spring MVC控制层框架&#x2F;img021_N1iTvQ8D3e.png)</p>
</li>
</ol>
<h4 id="2-4-所有断点总结"><a href="#2-4-所有断点总结" class="headerlink" title="2.4 所有断点总结"></a>2.4 所有断点总结</h4><p>断点位置基准：SpringMVC 版本采用 6.0.6 且源码已经下载，包含注释。</p>
<table>
<thead>
<tr>
<th>所在类</th>
<th>所在方法</th>
<th>断点行数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>DispatcherServlet</td>
<td>doDispatch()</td>
<td>1057</td>
<td>创建调用链对象</td>
</tr>
<tr>
<td>DispatcherServlet</td>
<td>doDispatch()</td>
<td>1064</td>
<td>创建 HandlerAdapter 对象</td>
</tr>
<tr>
<td>DispatcherServlet</td>
<td>doDispatch()</td>
<td>1076</td>
<td>调用拦截器 preHandle()方法</td>
</tr>
<tr>
<td>DispatcherServlet</td>
<td>doDispatch()</td>
<td>1081</td>
<td>执行目标 handler 方法</td>
</tr>
<tr>
<td>DispatcherServlet</td>
<td>doDispatch()</td>
<td>1088</td>
<td>调用拦截器 postHandle()方法</td>
</tr>
<tr>
<td>DispatcherServlet</td>
<td>doDispatch()</td>
<td>1098</td>
<td>执行所有后续操作</td>
</tr>
<tr>
<td>DispatcherServlet</td>
<td>processDispatchResult()</td>
<td>1145</td>
<td>处理异常</td>
</tr>
<tr>
<td>DispatcherServlet</td>
<td>processDispatchResult()</td>
<td>1159</td>
<td>渲染视图</td>
</tr>
<tr>
<td>DispatcherServlet</td>
<td>processDispatchResult()</td>
<td>1177</td>
<td>调用拦截器 afterCompletion()方法</td>
</tr>
</tbody></table>
<h3 id="3-ContextLoaderListener"><a href="#3-ContextLoaderListener" class="headerlink" title="3. ContextLoaderListener"></a>3. ContextLoaderListener</h3><h4 id="3-1-配置分离相关问题"><a href="#3-1-配置分离相关问题" class="headerlink" title="3.1 配置分离相关问题"></a>3.1 配置分离相关问题</h4><p>目前情况：DispatcherServlet 加载 spring-mvc.xml，此时整个 Web 应用中只创建一个 IoC 容器。将来整合Mybatis、配置声明式事务，全部在 spring-mvc.xml 配置文件中配置也是可以的。可是这样会导致配置文件太长，不容易维护。</p>
<p>所以想到把配置文件分开：</p>
<ul>
<li>SpringMVC相关：spring-mvc.xml 配置文件</li>
<li>Spring和Mybatis相关：spring-persist.xml 配置文件 (命名随意，分离思维)</li>
</ul>
<p>配置文件分开之后，可以让 DispatcherServlet 加载多个配置文件。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果希望这两个配置文件使用不同的机制来加载：</p>
<ul>
<li>DispatcherServlet 加载 spring-mvc.xml 配置文件：它们和处理浏览器请求相关</li>
<li>ContextLoaderListener 加载 spring-persist.xml 配置文件：不需要处理浏览器请求，需要配置持久化层相关功能</li>
</ul>
<p>此时会带来一个新的问题：在一个 Web 应用中就会出现两个 IOC 容器</p>
<ul>
<li>DispatcherServlet 创建一个 IOC 容器</li>
<li>ContextLoaderListener 创建一个 IOC 容器</li>
</ul>
<p>注意：本节我们探讨的这个技术方案并不是『必须』这样做，而仅仅是『可以』这样做。</p>
<h4 id="3-2-配置ContextLoaderListener"><a href="#3-2-配置ContextLoaderListener" class="headerlink" title="3.2 配置ContextLoaderListener"></a>3.2 配置ContextLoaderListener</h4><ol>
<li><p>创建 spring-persist.xml</p>
<p>![](Spring MVC控制层框架&#x2F;img022_lw63yzM-MW.png)</p>
</li>
<li><p>配置 ContextLoaderListener</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过全局初始化参数指定 Spring 配置文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-persist.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定全类名，配置监听器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>ContextLoaderListener</p>
<p>![](Spring MVC控制层框架&#x2F;img023_gMZk-O9CJH.png)</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>执行时机</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>contextInitialized()</td>
<td>Web 应用启动时执行</td>
<td>创建并初始化 IOC 容器</td>
</tr>
<tr>
<td>contextDestroyed()</td>
<td>Web 应用卸载时执行</td>
<td>关闭 IOC 容器</td>
</tr>
</tbody></table>
</li>
<li><p>ContextLoader</p>
<p>ContextLoader 类是 ContextLoaderListener 类的父类。</p>
<p>指定配置文件位置的参数名:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Name of servlet context parameter (i.e., &#123;<span class="doctag">@value</span>&#125;) that can specify the</span></span><br><span class="line"><span class="comment"> * config location for the root context, falling back to the implementation&#x27;s</span></span><br><span class="line"><span class="comment"> * default otherwise.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.support.XmlWebApplicationContext#DEFAULT_CONFIG_LOCATION</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIG_LOCATION_PARAM</span> <span class="operator">=</span> <span class="string">&quot;contextConfigLocation&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>初始化 IOC 容器</p>
<p>方法名：initWebApplicationContext()</p>
<p>创建 IOC 容器</p>
<p>方法名：createWebApplicationContext()</p>
</li>
</ol>
<h4 id="3-3-探讨两个IoC容器之间关系"><a href="#3-3-探讨两个IoC容器之间关系" class="headerlink" title="3.3 探讨两个IoC容器之间关系"></a>3.3 探讨两个IoC容器之间关系</h4><p>![](Spring MVC控制层框架&#x2F;image_m_4ZcyUS8E.png)</p>
<p>打印两个 IOC 容器对象的 toString() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">springIOC</span> <span class="operator">=</span> servletContext.getAttribute(<span class="string">&quot;org.springframework.web.context.WebApplicationContext.ROOT&quot;</span>);</span><br><span class="line">log.debug(springIOC.toString());</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">springMVCIOC</span> <span class="operator">=</span> servletContext.getAttribute(<span class="string">&quot;org.springframework.web.servlet.FrameworkServlet.CONTEXT.dispatcherServlet&quot;</span>);</span><br><span class="line">log.debug(springMVCIOC.toString());</span><br></pre></td></tr></table></figure>

<p>打印效果是：</p>
<blockquote>
<p>**Root **WebApplicationContext, started on Thu Jun 17 14:49:17 CST 2021<br>……<br>WebApplicationContext for namespace ‘dispatcherServlet-servlet’, started on Thu Jun 17 14:49:18 CST 2021, <strong>parent</strong>: Root WebApplicationContext</p>
</blockquote>
<p>结论：两个组件分别创建的 IOC 容器是<strong>父子</strong>关系。</p>
<ul>
<li>父容器：ContextLoaderListener 创建的 IOC 容器</li>
<li>子容器：DispatcherServlet 创建的 IOC 容器</li>
</ul>
<p>父子关系是如何决定的？</p>
<ul>
<li>Tomcat 在读取 web.xml 之后，加载组件的顺序就是监听器、过滤器、Servlet。</li>
<li>ContextLoaderListener 初始化时如果检查到有已经存在的根级别 IOC 容器，那么会抛出异常。</li>
<li>DispatcherServlet 创建的 IOC 容器会在初始化时先检查当前环境下是否存在已经创建好的 IOC 容器。<ul>
<li>如果有：则将已存在的这个 IOC 容器设置为自己的父容器</li>
<li>如果没有：则将自己设置为 root 级别的 IOC 容器</li>
</ul>
</li>
</ul>
<p>DispatcherServlet 创建的 IOC 容器设置父容器的源码截图：</p>
<p>所在类：org.springframework.web.servlet.FrameworkServlet</p>
<p>所在方法：createWebApplicationContext()</p>
<p>![](Spring MVC控制层框架&#x2F;img024__fEN2w3a99.png)</p>
<h4 id="3-4-两个IoC容器之间Bean访问"><a href="#3-4-两个IoC容器之间Bean访问" class="headerlink" title="3.4 两个IoC容器之间Bean访问"></a>3.4 两个IoC容器之间Bean访问</h4><p>![](Spring MVC控制层框架&#x2F;img113_B0qo4n9vts.png)</p>
<p>spring-mvc.xml配置方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wzb.spring.component.controller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>spring-persist.xml配置方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wzb.spring.component.service,com.wzb.spring.component.dao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以bean所属IOC容器的关系：</p>
<ul>
<li>父容器<ul>
<li>EmpService</li>
<li>EmpDao</li>
</ul>
</li>
<li>子容器<ul>
<li>EmpController</li>
</ul>
</li>
</ul>
<p>结论：子容器中的 EmpController 装配父容器中的 EmpService 能够正常工作。说明子容器可以访问父容器中的bean。</p>
<p>分析：“子可用父，父不能用子”的根本原因是子容器中有一个属性 &lt;span style&#x3D;”color:blue;font-weight:bold;”&gt;getParent()&lt;&#x2F;span&gt; 可以获取到父容器这个对象的引用。</p>
<p>源码依据：</p>
<ul>
<li>在 AbstractApplicationContext 类中，有 parent 属性</li>
<li>在 AbstractApplicationContext 类中，有获取 parent 属性的 getParent() 方法</li>
<li>子容器可以通过 getParent() 方法获取到父容器对象的引用</li>
<li>进而调用父容器中类似 “getBean()” 这样的方法获取到需要的 bean 完成装配</li>
<li>而父容器中并没有类似 “getChildren()“ 这样的方法，所以没法拿到子容器对象的引用</li>
</ul>
<p>![](Spring MVC控制层框架&#x2F;img114_NCIr6ftjXa.png)</p>
<h4 id="3-5-有可能重复对象"><a href="#3-5-有可能重复对象" class="headerlink" title="3.5 有可能重复对象"></a>3.5 有可能重复对象</h4><p>![](Spring MVC控制层框架&#x2F;img115_DlCdffhvJZ.png)</p>
<p>查看日志确认是否重复创建了对象</p>
<blockquote>
<p>Root WebApplicationContext: initialization started<br>……</p>
</blockquote>
<p>Creating shared instance of singleton bean ‘helloDao’<br>Creating shared instance of singleton bean ‘helloHandler’<br>Creating shared instance of singleton bean ‘helloService’</p>
<p>……<br>Root WebApplicationContext initialized in 1150 ms<br>Refreshing WebApplicationContext for namespace ‘dispatcherServlet-servlet’<br>……</p>
<p>Creating shared instance of singleton bean ‘helloDao’<br>Creating shared instance of singleton bean ‘helloHandler’<br>Creating shared instance of singleton bean ‘helloService’</p>
<p>重复创建对象的问题</p>
<ul>
<li>浪费内存空间</li>
<li>两个 IOC 容器能力是不同的<ul>
<li><p>spring-mvc.xml：仅配置和处理请求相关的功能。所以不能给 service 类附加声明式事务功能。</p>
<p>结论：基于 spring-mvc.xml 配置文件创建的 EmpService 的 bean 不带有声明式事务的功能</p>
<p>影响：DispatcherServlet 处理浏览器请求时会调用自己创建的 EmpController，然后再调用自己创建的EmpService，而这个 EmpService 是没有事务的，所以处理请求时&lt;span style&#x3D;”color:blue;font-weight:bold;”&gt;没有事务功能的支持&lt;&#x2F;span&gt;。</p>
</li>
<li><p>spring-persist.xml：配置声明式事务。所以可以给 service 类附加声明式事务功能。</p>
<p>结论：基于 spring-persist.xml 配置文件创建的 EmpService 有声明式事务的功能</p>
<p>影响：由于 DispatcherServlet 的 IOC 容器会优先使用自己创建的 EmpController，进而装配自己创建的EmpService，所以基于 spring-persist.xml 配置文件创建的有声明式事务的 EmpService 用不上。</p>
</li>
</ul>
</li>
</ul>
<p>解决重复创建对象的问题</p>
<p>解决方案一[建议使用]</p>
<p>让两个配置文件配置自动扫描的包时，各自扫描各自的组件。</p>
<ul>
<li>SpringMVC 就扫描 XxxHandler、XXXController</li>
<li>Spring 扫描 XxxService 和 XxxDao</li>
</ul>
<p>解决方案二</p>
<p>如果由于某种原因，必须扫描同一个包，确实存在重复创建对象的问题，可以采取下面的办法处理。</p>
<ul>
<li>spring-mvc.xml 配置文件在整体扫描的基础上进一步配置：仅包含被 @Controller 注解标记的类。</li>
<li>spring-persist.xml 配置在整体扫描的基础上进一步配置：排除被 @Controller 注解标记的类。</li>
</ul>
<p>具体spring-mvc.xml配置文件中的配置方式如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 两个Spring的配置文件扫描相同的包 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 为了解决重复创建对象的问题，需要进一步制定扫描组件时的规则 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 目标：『仅』包含@Controller注解标记的类 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- use-default-filters=&quot;false&quot;表示关闭默认规则，表示什么都不扫描，此时不会把任何组件加入IOC容器；</span></span><br><span class="line"><span class="comment">        再配合context:include-filter实现“『仅』包含”效果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wzb.spring.component&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- context:include-filter标签配置一个“扫描组件时要包含的类”的规则，追加到默认规则中 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- type属性：指定规则的类型，根据什么找到要包含的类，现在使用annotation表示基于注解来查找 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- expression属性：规则的表达式。如果type属性选择了annotation，那么expression属性配置注解的全类名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体spring-persist.xml配置文件中的配置方式如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 两个Spring的配置文件扫描相同的包 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在默认规则的基础上排除标记了@Controller注解的类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wzb.spring.component&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置具体排除规则：把标记了@Controller注解的类排除在扫描范围之外 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h4><ul>
<li>DispatcherServlet 和 ContextLoaderListener 并存<ul>
<li>DispatcherServlet 负责加载 SpringMVC 的配置文件，例如：spring-mvc.xml</li>
<li>ContextLoaderListener 负责加载 Spring 的配置文件，例如：spring-persist.xml</li>
</ul>
</li>
<li>两个 IOC 容器的关系：<ul>
<li>ContextLoaderListener 创建的容器是父容器</li>
<li>DispatcherServlet 创建的容器是子容器</li>
</ul>
</li>
<li>bean 的装配<ul>
<li>子容器可以访问父容器中的 bean</li>
<li>父容器不能访问子容器中的 bean</li>
</ul>
</li>
<li>两个容器扫描同一个包会导致重复创建对象<ul>
<li>解决办法一：各自扫描各自的包</li>
<li>解决办法二：<ul>
<li>DispatcherServlet 创建的容器仅扫描 handler</li>
<li>ContextLoaderListener 创建的容器不扫描 handler</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>通过遵循 RESTful 架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web 服务。RESTful API 的特点是简单、清晰，并且易于使用和理解，它们使用标准的 HTTP 方法和状态码进行通信，不需要额外的协议和中间件。</p>
<p>RESTful 架构通常用于构建 Web API，提供数据的传输和操作。它可以用于各种应用场景，包括客户端-服务器应用、单页应用（SPA）、移动应用程序和微服务架构等。</p>
<p>总而言之，RESTful 是一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/05/01/Spring%20MVC%E6%8E%A7%E5%88%B6%E5%B1%82%E6%A1%86%E6%9E%B6/">http://example.com/2024/05/01/Spring%20MVC%E6%8E%A7%E5%88%B6%E5%B1%82%E6%A1%86%E6%9E%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">学习笔记</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/05/23/MyBatis%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/" title="MyBatis持久层框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">MyBatis持久层框架</div></div><div class="info-2"><div class="info-item-1">MyBatis持久层框架目录 一、Mybatis简介 1. 简介 2. 持久层框架对比 3. 快速入门（基于Mybatis3方式）   二、日志框架扩展 1. 用日志打印替代sout 2. Java日志体系演变 3. 最佳拍档用法 4. Lombok插件的使用 4.1 Lombok简介 4.2 Lombok安装 4.3 Lombok使用注解     三、MyBatis基本使用 1. 向SQL语句传参 1.1 mybatis日志输出配置 1.2 #{}形式 1.3 ${}形式   2. 数据输入 2.1 Mybatis总体机制概括 2.2 概念说明 2.3 单个简单类型参数 2.4 实体类类型参数 2.5 零散的简单类型数据 2.6 Map类型参数   3. 数据输出 3.1 输出概述 3.2 单个简单类型 3.3 返回实体类对象 3.4 返回Map类型 3.5 返回List类型 3.6 返回主键值 3.7 实体类属性和数据库字段对应关系   4. CRUD强化练习 5. mapperXML标签总结   四、MyBatis多表映射 1. 多表映射概念 2. 对一映射 3. 对多映射...</div></div></div></a><a class="pagination-related" href="/2024/03/02/Spring%E4%BC%81%E4%B8%9A%E5%BC%80%E5%8F%91%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6/" title="Spring企业开发核心框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Spring企业开发核心框架</div></div><div class="info-2"><div class="info-item-1">Spring企业开发核心框架目录 一、框架前言 1. 总体技术体系 2. 框架概念和理解   二、Spring Framework简介 1. Spring 和 SpringFramework 2. SpringFramework主要功能模块 3. SpringFramework 主要优势   三、Spring IoC 容器概念 1. 组件和组件管理概念 2. Spring IoC容器和容器实现 3. Spring IoC &#x2F; DI概念总结   四、Spring IoC &#x2F; DI 实现 1.  Spring IoC &#x2F; DI 实现步骤 2. 基于XML方式管理Bean 2.1 实验一： 声明配置文件和创建容器 2.2 实验二： 获取Bean 2.3 实验三： Bean属性赋值：setter注入 2.4 实验四： Bean属性赋值：引用其他Bean 2.5 实验五： Bean 属性赋值：内部Bean声明(了解) 2.6 实验六： Bean 属性赋值：引入外部Properties配置参数 2.7 实验七： 高级特性：FactoryBean特性 2.8 实验...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">明</div><div class="author-info-description">记录学习过程中的点点滴滴</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-MVC%E6%8E%A7%E5%88%B6%E5%B1%82%E6%A1%86%E6%9E%B6"><span class="toc-text">Spring MVC控制层框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81SpringMVC%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%93%E9%AA%8C"><span class="toc-text">一、SpringMVC简介和体验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">1. 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="toc-text">2. 主要作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%92%8C%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E7%90%86%E8%A7%A3"><span class="toc-text">3. 核心组件和调用流程理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BF%AB%E9%80%9F%E4%BD%93%E9%AA%8C"><span class="toc-text">4. 快速体验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SpringMVC%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-text">二、SpringMVC接收数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE"><span class="toc-text">1. 访问路径设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">2. 接收参数（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-param-%E5%92%8C-json%E5%8F%82%E6%95%B0%E6%AF%94%E8%BE%83"><span class="toc-text">2.1 param 和 json参数比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-param%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6"><span class="toc-text">2.2 param参数接收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E8%B7%AF%E5%BE%84-%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6"><span class="toc-text">2.3 路径 参数接收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-json%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6"><span class="toc-text">2.4 json参数接收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8E%A5%E6%94%B6Cookie%E6%95%B0%E6%8D%AE"><span class="toc-text">3. 接收Cookie数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%95%B0%E6%8D%AE"><span class="toc-text">4. 接收请求头数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8E%9F%E7%94%9FApi%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C"><span class="toc-text">5. 原生Api对象操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%85%B1%E4%BA%AB%E5%9F%9F%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C"><span class="toc-text">6. 共享域对象操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%B1%9E%E6%80%A7%EF%BC%88%E5%85%B1%E4%BA%AB%EF%BC%89%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9B%9E%E9%A1%BE"><span class="toc-text">6.1 属性（共享）域作用回顾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-Request%E7%BA%A7%E5%88%AB%E5%B1%9E%E6%80%A7%EF%BC%88%E5%85%B1%E4%BA%AB%EF%BC%89%E5%9F%9F"><span class="toc-text">6.2 Request级别属性（共享）域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-Session%E7%BA%A7%E5%88%AB%E5%B1%9E%E6%80%A7%EF%BC%88%E5%85%B1%E4%BA%AB%EF%BC%89%E5%9F%9F"><span class="toc-text">6.3 Session级别属性（共享）域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-Application%E7%BA%A7%E5%88%AB%E5%B1%9E%E6%80%A7%EF%BC%88%E5%85%B1%E4%BA%AB%EF%BC%89%E5%9F%9F"><span class="toc-text">6.4 Application级别属性（共享）域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81SpringMVC%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE"><span class="toc-text">三、SpringMVC响应数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-handler%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">1. handler方法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6"><span class="toc-text">2. 页面跳转控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%BF%AB%E9%80%9F%E8%BF%94%E5%9B%9Ejsp%E8%A7%86%E5%9B%BE"><span class="toc-text">2.1 快速返回jsp视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">2.2 转发和重定向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BF%94%E5%9B%9EJSON%E6%95%B0%E6%8D%AE%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">3. 返回JSON数据（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87"><span class="toc-text">3.1 前置准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-ResponseBody"><span class="toc-text">3.2 @ResponseBody</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-RestController"><span class="toc-text">3.3 @RestController</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BF%94%E5%9B%9E%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86"><span class="toc-text">4. 返回静态资源处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81RESTFul%E9%A3%8E%E6%A0%BC%E8%AE%BE%E8%AE%A1"><span class="toc-text">四、RESTFul风格设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-RESTFul%E9%A3%8E%E6%A0%BC%E6%A6%82%E8%BF%B0"><span class="toc-text">1. RESTFul风格概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-RESTFul%E9%A3%8E%E6%A0%BC%E7%AE%80%E4%BB%8B"><span class="toc-text">1.1 RESTFul风格简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-RESTFul%E9%A3%8E%E6%A0%BC%E7%89%B9%E7%82%B9"><span class="toc-text">1.2 RESTFul风格特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-RESTFul%E9%A3%8E%E6%A0%BC%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-text">1.3 RESTFul风格设计规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-RESTFul%E9%A3%8E%E6%A0%BC%E5%A5%BD%E5%A4%84"><span class="toc-text">1.4 RESTFul风格好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-RESTFul%E9%A3%8E%E6%A0%BC%E5%AE%9E%E6%88%98"><span class="toc-text">2. RESTFul风格实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">2.1 需求分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-RESTFul%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.2 RESTFul风格接口设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%90%8E%E5%8F%B0%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3 后台接口实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%9F%BA%E4%BA%8ERESTFul%E9%A3%8E%E6%A0%BC%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%BB%83%E4%B9%A0"><span class="toc-text">五、基于RESTFul风格增删改查练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A1%88%E4%BE%8B%E5%8A%9F%E8%83%BD%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90"><span class="toc-text">1. 案例功能和接口分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%8A%9F%E8%83%BD%E9%A2%84%E8%A7%88"><span class="toc-text">1.1 功能预览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90"><span class="toc-text">1.2 接口分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87"><span class="toc-text">2. 工程项目准备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA"><span class="toc-text">2.1 前端项目搭建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA"><span class="toc-text">2.2 后端项目搭建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E7%8E%B0"><span class="toc-text">3. 增删改查实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E9%A1%B9%E7%9B%AE%E6%A0%B9%E8%B7%AF%E5%BE%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">4.1 项目根路径设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-SpringMVC%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-text">4.2 SpringMVC解决跨域问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E4%B8%9A%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.3 业务实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81SpringMVC%E5%85%B6%E4%BB%96%E6%89%A9%E5%B1%95"><span class="toc-text">六、SpringMVC其他扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-text">1. 异常处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1 异常处理概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BC%82%E5%B8%B8%E5%A5%BD%E5%A4%84"><span class="toc-text">1.2 声明式异常好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%BC%82%E5%B8%B8%E5%A3%B0%E6%98%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">1.3 基于注解异常声明异常处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8"><span class="toc-text">2. 拦截器使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%8B%A6%E6%88%AA%E5%99%A8%E6%A6%82%E5%BF%B5"><span class="toc-text">2.1 拦截器概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8"><span class="toc-text">2.2 拦截器使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%9C%E7%94%A8%E4%BD%8D%E7%BD%AE%E5%9B%BE%E8%A7%A3"><span class="toc-text">2.3 拦截器作用位置图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E6%8B%A6%E6%88%AA%E5%99%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">2.4 拦截器案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C"><span class="toc-text">3. 参数校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD-x20"><span class="toc-text">4.文件上传和下载 </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-text">4.1 文件上传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD"><span class="toc-text">4.2 文件下载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81SpringMVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">七、SpringMVC底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-text">1. 启动配置流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-Servlet-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E9%A1%BE"><span class="toc-text">1.1 Servlet 生命周期回顾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C%E8%B0%83%E7%94%A8%E8%B7%AF%E7%BA%BF%E5%9B%BE"><span class="toc-text">1.2 初始化操作调用路线图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-SpringMVC-IoC-%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA"><span class="toc-text">1.3 SpringMVC IoC 容器创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%B0%86-SpringMVC-IoC%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%85%A5%E5%BA%94%E7%94%A8%E5%9F%9F"><span class="toc-text">1.4 将 SpringMVC IoC容器对象存入应用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1.5 请求映射初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-%E5%B0%8F%E7%BB%93"><span class="toc-text">1.6 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%8E%9F%E7%90%86"><span class="toc-text">2. 请求处理流程原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%80%BB%E4%BD%93%E9%98%B6%E6%AE%B5"><span class="toc-text">2.1 总体阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%B0%83%E7%94%A8%E5%89%8D%E9%98%B6%E6%AE%B5"><span class="toc-text">2.2 调用前阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E8%B0%83%E7%94%A8%E5%90%8E%E9%98%B6%E6%AE%B5"><span class="toc-text">2.3调用后阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E6%89%80%E6%9C%89%E6%96%AD%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-text">2.4 所有断点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ContextLoaderListener"><span class="toc-text">3. ContextLoaderListener</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E9%85%8D%E7%BD%AE%E5%88%86%E7%A6%BB%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-text">3.1 配置分离相关问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E9%85%8D%E7%BD%AEContextLoaderListener"><span class="toc-text">3.2 配置ContextLoaderListener</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%8E%A2%E8%AE%A8%E4%B8%A4%E4%B8%AAIoC%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-text">3.3 探讨两个IoC容器之间关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E4%B8%A4%E4%B8%AAIoC%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4Bean%E8%AE%BF%E9%97%AE"><span class="toc-text">3.4 两个IoC容器之间Bean访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E6%9C%89%E5%8F%AF%E8%83%BD%E9%87%8D%E5%A4%8D%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.5 有可能重复对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%B0%8F%E7%BB%93"><span class="toc-text">3.5 小结</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/13/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="Linux操作系统">Linux操作系统</a><time datetime="2024-09-13T04:02:03.000Z" title="发表于 2024-09-13 12:02:03">2024-09-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/03/%E9%A3%9F%E5%88%86%E9%80%9F%E9%80%92%E9%A1%B9%E7%9B%AE/" title="食分速递项目">食分速递项目</a><time datetime="2024-08-03T01:12:58.000Z" title="发表于 2024-08-03 09:12:58">2024-08-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/03/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D/" title="软件开发整体介绍">软件开发整体介绍</a><time datetime="2024-08-02T23:42:56.000Z" title="发表于 2024-08-03 07:42:56">2024-08-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/06/springboot%E5%AD%A6%E4%B9%A0/" title="springboot学习">springboot学习</a><time datetime="2024-07-06T12:42:13.000Z" title="发表于 2024-07-06 20:42:13">2024-07-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/02/SSM%E6%95%B4%E5%90%88/" title="SSM整合">SSM整合</a><time datetime="2024-06-02T01:14:43.000Z" title="发表于 2024-06-02 09:14:43">2024-06-02</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 明</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>